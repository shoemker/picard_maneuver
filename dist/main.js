/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/bridge_view.js":
/*!****************************!*\
  !*** ./src/bridge_view.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nclass BridgeView {\n\tconstructor(images){\n\t\tthis.width = 200;\n\t\tthis.height = 150;\n\t\tthis.bridgeImage = images.bridge;\n\t\tthis.bridgeShaken = images.bridgeShaken;\n\n\t\tthis.bridgePos = { x: Utils.getCanvasDim().x - this.width, y: 0}\n\n\t\tthis.shakeCounter = 0;\n\t\tthis.phaserCounter = 0;\n\t\tthis.torpedoCounter = 0;\n\t\t// this.engineDamCounter = 0;\n\t\t// this.beamDamCounter = 0;\n\t\t// this.torpDamCounter = 0;\n\n\t\tthis.alive = true;\n\t\tthis.lights = 0;\n\t}\n\n\tdestroyed() { this.alive = false; }\n\tshakeOn() { this.shakeCounter = 1; }\n\tphasersBubbleOn() { this.phaserCounter = 1; }\n\ttorpedosBubbleOn() { this.torpedoCounter = 1; }\n\n\t// enginDamBubbleOn() { \n\t// \tthis.engineDamCounter = 1; \n\t// \tthis.beamDamCounter = 0;\n\t// \tthis.torpDamCounter = 0;\n\t// };\n\n\t// beamDamBubbleOn() {\n\t// \tthis.engineDamCounter = 0;\n\t// \tthis.beamDamCounter = 1;\n\t// \tthis.torpDamCounter = 0;\n\t// };\n\n\t// torpDamBubbleOn() { t\n\t// \tthis.engineDamCounter = 0;\n\t// \tthis.beamDamCounter = 0;\n\t// \tthis.torpDamCounter = 1;\n\t// };\n\n\tstep() {\n\t\tif (this.shakeCounter > 0) this.shakeCounter++;\n\t\tif (this.shakeCounter === 30) this.shakeCounter = 0;\n\n\t\tif (this.phaserCounter > 0) this.phaserCounter++;\n\t\tif (this.phaserCounter === 40) this.phaserCounter = 0;\n\n\t\tif (this.torpedoCounter > 0) this.torpedoCounter++;\n\t\tif (this.torpedoCounter === 40) this.torpedoCounter = 0;\n\n\t\tthis.stepLights();\n\t}\n\n\n\tdraw(ctx) {\n\t\tif (this.alive) {\n\n\t\t\tif (this.shakeCounter !== 0) this.shakeBridge(ctx);\n\t\t\telse {\n\t\t\t\tctx.drawImage(this.bridgeImage, 0,0, 1022, 765, \n\t\t\t\t\tthis.bridgePos.x, this.bridgePos.y,this.width, this.height);\n\t\t\t\t\t\n\t\t\t\tif (this.phaserCounter > 0) {\n\t\t\t\t\tthis.drawSpeachBubble(ctx, { x: Utils.getCanvasDim().x - 150, y: 60}, \n\t\t\t\t\t\t100, 25, { x: this.bridgePos.x + 63, y: 85 });\t\n\n\t\t\t\t\tthis.drawText(ctx, this.bridgePos.x + 7, 65, \"Firing Phasers\", 13);\n\t\t\t\t}\n\t\t\t\telse if (this.torpedoCounter > 0) {\n\t\t\t\t\tthis.drawSpeachBubble(ctx, { x: Utils.getCanvasDim().x - 50, y: 107}, \n\t\t\t\t\t\t100,25, { x: this.bridgePos.x + 177, y: 131 });\n\n\t\t\t\t\tthis.drawText(ctx, Utils.getCanvasDim().x - 95, 111, \"Torpedos Away\", 13);\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tthis.drawLights(ctx);\n\t\t\t}\n\n\t\t\tthis.drawBorder(ctx);\n\t\t}\n\t}\n\n\n\tstepLights(){\n\t\tthis.lights++;\n\t\tif (this.lights > 40) this.lights = 0;\n\t}\n\n\n\tdrawLights(ctx) {\n\t\tif (this.lights < 20) {\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 7, 28, 1, \"red\");\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 37, 14, 1, \"yellow\");\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 140, 18, 1, \"yellow\");\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 190, 80, 1, \"yellow\");\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 193, 145, 1, \"red\");\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 193, 145, 1, \"red\");\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 54, 98, 1, \"yellow\");\n\n\t\t}\n\t\telse {\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 22, 21, 1,\"lightgreen\");\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 150, 28, 1,\"lightgreen\");\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 176, 46, 1,\"red\");\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 193, 135, 1,\"lightgreen\");\n\t\t\tUtils.drawFilledCircle(ctx, this.bridgePos.x + 87, 123, 1, \"red\");\n\t\t}\n\t}\n\n\n\tdrawBorder(ctx) {\n\t\tlet lineWidth = 10;\n\t\tctx.lineWidth = lineWidth;\n\t\tctx.strokeStyle = \"grey\";\n\t\tctx.beginPath();\n\t\tctx.moveTo(this.bridgePos.x - lineWidth / 2, this.bridgePos.y);\n\t\tctx.lineTo(this.bridgePos.x - lineWidth / 2, this.bridgePos.y + this.height + lineWidth / 2);\n\t\tctx.lineTo(Utils.getCanvasDim().x, this.bridgePos.y + this.height + lineWidth / 2);\n\t\tctx.stroke();\n\t}\n\n\n\tdrawSpeachBubble(ctx, center, width, height, speaker) {\n\t\tconst top = { x: center.x, y: center.y - height / 2 };\n\t\tconst left = { x: center.x - width / 2, y: center.y }\n\t\tconst right = { x: center.x + width / 2, y: center.y }\n\t\tconst bottom = { x: center.x, y: center.y + height / 2 }\n\n\t\tctx.fillStyle = \"white\";\n\n\t\tctx.beginPath();\n\t\tctx.moveTo(top.x, top.y);\n\n\t\t// quadraticCurveTo(cp1x, cp1y, x, y) cp1 is control point\n\t\tctx.quadraticCurveTo(left.x, top.y, left.x, left.y); // top to left\n\t\tctx.quadraticCurveTo(left.x, bottom.y, bottom.x,bottom.y); // left to bottom\n\t\tctx.quadraticCurveTo(right.x, bottom.y, right.x, right.y); // to right\n\t\tctx.quadraticCurveTo(right.x, top.y, top.x, top.y); // to top\n\t\tctx.fill();\n\n\t\t// triange to speaker\n\t\tctx.beginPath();\n\t\tctx.moveTo(center.x - 10, center.y);\n\t\tctx.lineTo(speaker.x, speaker.y);\n\t\tctx.lineTo(center.x + 10, center.y);\n\t\tctx.fill();\n\t}\n\n\n\tdrawText(ctx, x, y, message, size = 16){\n\t\tctx.fillStyle = \"black\";\n\t\tctx.font = size +\"px ComicRelief\";\n\t\tctx.fillText(message, x, y);\n\t}\n\n\n\t// this function makes the bridge view shake when ship is hit\n\tshakeBridge(ctx) {\n\t\tctx.save();\n\t\tctx.translate(Math.random() * 7, Math.random() * 7);\n\n\t\tctx.drawImage(this.bridgeShaken, 0, 0, 510, 380,\n\t\t\tthis.bridgePos.x, this.bridgePos.y, this.width, this.height);\n\n\t\tthis.drawSpeachBubble(ctx, { x: Utils.getCanvasDim().x - 50, y: 20},90,30, \n\t\t\t{ x: this.bridgePos.x + 125, y: 50 });\n\n\t\tthis.drawText(ctx, Utils.getCanvasDim().x - 90, 26, \"Direct Hit!\")\n\n\t\tctx.restore();\n\t}\n}\n\nmodule.exports = BridgeView;\n\n//# sourceURL=webpack:///./src/bridge_view.js?");

/***/ }),

/***/ "./src/enemyAI.js":
/*!************************!*\
  !*** ./src/enemyAI.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nclass EnemyAI  {\n\tconstructor(aiShip, game, targeting = false) {\n\t\tthis.aiShip = aiShip;\n\t\tthis.game = game;\n\t\tthis.targeting = targeting\n\t\tthis.beenOffScreen = false;\n\n\t\tthis.turnLeftLength = 0;\n\t\tthis.turnRightLength = 0;\n\t\tthis.turnCounter = 0;\n\t\tthis.reverseCount = 0;\n\t\tthis.reverseCountMax = 60;\n\t}\n\n\tconsultAI(onscreen){\n\t\tif (!onscreen && this.aiShip !== this.game.main) this.beenOffScreen = true\n\t\tif (this.targeting) this.changeTarget(onscreen);\n\n\t\tif (this.aiShip.getTarget()) {\n\t\t\tconst angleOfOpponent = Utils.angleToOtherShip(this.aiShip, this.aiShip.getTarget());\n\n\t\t\tthis.changeSpeed();\n\t\t\tthis.fireBeamWeapon(onscreen);\n\t\t\tthis.checkForRearEnemy(angleOfOpponent);\n\t\t\tthis.turningAndTorpedoes(angleOfOpponent, onscreen);\n\t\t} \n\t\telse this.aiShip.setTarget(this.game.randomTarget(this.aiShip));\n\t}\n\t\n\n\tchangeTarget(onscreen) {\n\t\tlet potentialTargets = [];\n\n\t\tif (!onscreen && this.aiShip !== this.game.main) this.aiShip.setTarget(this.game.main);\n\t\telse if (onscreen && this.beenOffScreen) {\n\t\t\tthis.aiShip.setTarget(this.game.randomTarget(this.aiShip))\n\t\t\tthis.beenOffScreen = false;\n\t\t\t// if (!this.aiShip.isEnemy() && this.aiShip.getTarget() === this.game.main) debugger;\n\t\t}\n\t\telse {\n\t\t\tconst target = this.aiShip.getTarget()\n\t\t\tif (!target || target.isGone() || !target.onscreen())\n\t\t\t\t\tthis.aiShip.setTarget(this.game.randomTarget(this.aiShip))\n\n\t\t\t// if an enemy ship is in front of the ship in question, it becomes the target\n\t\t\tif (this.aiShip.isEnemy()) potentialTargets = this.game.allies.concat(this.game.main);\n\t\t\telse potentialTargets = this.game.enemies;\n\t\t\tpotentialTargets.forEach((target) => {\n\t\t\t\tconst angle = Utils.angleToOtherShip(this.aiShip, target)\n\t\t\t\tif ((angle > (2 * Math.PI - Math.PI / 9)) || (angle < Math.PI / 9) && this.aiShip.torpedosReady()) \n\t\t\t\t\tthis.aiShip.setTarget(target);\n\t\t\t});\n\t\t}\n\t}\n\n\n\tfireBeamWeapon(onscreen) {\n\t\tif (this.aiShip.phaserReady() && onscreen && this.aiShip.getTarget().onscreen()) \n\t\t\tthis.aiShip.firePhasers();\n\t}\n\n\t// if the other ship is sitting behind, stop\n\tcheckForRearEnemy(angleOfOpponent) {\n\t\tif (Math.abs(Math.PI - angleOfOpponent) < .4 &&\n\t\t\tUtils.distance(this.aiShip.center(), this.aiShip.getTarget().center()) < 120 &&\n\t\t\tMath.abs(this.aiShip.getRotation() - this.aiShip.getTarget().getRotation()) < .4 &&\n\t\t\tthis.aiShip.torpedosReady()) {\n\t\t\tthis.reverseCount++;\n\t\t}\n\t}\n\t\n\n\tturningAndTorpedoes(angleOfOpponent, onscreen) {\n\t\t// if (this.aiShip.torpedosReady()) debugger;\n\t\tconst turnCircleMax = 180;\n\t\tif (!onscreen || this.aiShip.torpedosReady()) {\n\t\t\tif (angleOfOpponent > Math.PI /18 && angleOfOpponent <= Math.PI) {\n\t\t\t\tif (this.turnCounter === this.aiShip.getTurnRadius()) {\n\t\t\t\t\tif (this.turnRightLength < turnCircleMax) {\n\t\t\t\t\t\tthis.aiShip.changeDirection(1);\n\t\t\t\t\t\tthis.turnRightLength++;\n\t\t\t\t\t\tthis.turnLeftLength = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse this.aiShip.changeDirection(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (angleOfOpponent < Math.PI * 1.9444 && angleOfOpponent > Math.PI) {\n\t\t\t\tif (this.turnCounter === this.aiShip.getTurnRadius()) {\n\t\t\t\t\tif (this.turnLeftLength < turnCircleMax) {\n\t\t\t\t\t\tthis.aiShip.changeDirection(-1);\n\t\t\t\t\t\tthis.turnLeftLength++;\n\t\t\t\t\t\tthis.turnRightLength = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse this.aiShip.changeDirection(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.aiShip.getTarget().onscreen()) this.game.fireTorpedoes(this.aiShip);\n\t\t}\n\t\t// ai gets some randomness\n\t\telse {\n\t\t\tconst random = Math.random();\n\t\t\tif (random < .04) this.aiShip.changeDirection(1);\n\t\t\telse if (random > .96) this.aiShip.changeDirection(-1);\n\t\t}\n\n\t\tthis.turnCounter++;\n\t\tif (this.turnCounter > this.aiShip.getTurnRadius()) this.turnCounter = 0;\n\t}\n\n\n\tchangeSpeed() {\n\t\tconst speed = this.aiShip.getSpeed();\n\n\t\tconst targetSpeed = this.aiShip.getTarget().getSpeed();\n\t\tif (this.reverseCount !== 0) {\n\t\t\tthis.aiShip.power(-.5);\n\t\t\tthis.reverseCount++;\n\t\t\tif (this.reverseCount >= this.reverseCountMax) this.reverseCount = 0;\n\t\t}\n\t\telse if ((speed < 2 && speed < targetSpeed) || speed < 1) {\n\t\t\tthis.aiShip.power(.5);\n\t\t}\n\t\telse if ((speed > targetSpeed) && speed > 1) this.aiShip.power(-.5);\n\t}\n}\n\nmodule.exports = EnemyAI;\n\n//# sourceURL=webpack:///./src/enemyAI.js?");

/***/ }),

/***/ "./src/explosion.js":
/*!**************************!*\
  !*** ./src/explosion.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Explosion {\n\tconstructor(img, sound) {\n\t\tthis.img = img;\n\t\tthis.sound = sound;\n\t\tthis.index = 0;\n\n\t\t// these are the x,y coords for different sprites on the sheet\n\t\tthis.sheet = [\n\t\t\t[ 380, 854,  30,  26],\n\t\t\t[ 250, 852,  30,  30],\n\t\t\t[ 115, 845,  40,  40],\n\n\t\t\t[ 760, 715,  50,  45],\n\t\t\t[ 628, 710,  53,  50],\n\t\t\t[ 495, 705,  60,  60],\n\t\t\t[ 360, 705,  65,  60],\n\t\t\t[ 230, 705,  70,  65],\n\t\t\t[ 100, 705,  70,  65],\n\n\t\t\t[ 750, 575,  70,  70],\n\t\t\t[ 618, 570,  74,  75],\n\t\t\t[ 490, 570,  70,  75],\n\t\t\t[ 357, 570,  75,  75],\n\t\t\t[ 225, 570,  77,  75],\n\t\t\t[ 100, 570,  70,  75],\n\n\t\t\t[ 748, 435,  74,  90],\n\t\t\t[ 616, 435,  78,  90],\t\t\t\n\t\t\t[ 488, 435,  74,  90],\n\t\t\t[ 355, 435,  79,  90],\t\t\t\n\t\t\t[ 223, 435,  81,  90],\n\t\t\t[  98, 435,  74,  90],\n\n\t\t\t[ 740, 290, 100, 115],\n\t\t\t[ 605, 290, 105, 115],\n\t\t\t[ 470, 290, 110, 115],\n\t\t\t[ 340, 290, 110, 115],\n\t\t\t[ 210, 290, 110, 115],\n\t\t\t[  90, 290,  90, 115],\n\n\t\t\t[ 730, 160, 110, 110],\n\t\t\t[ 600, 160, 110, 110],\n\t\t\t[ 470, 160, 110, 110],\n\t\t\t[ 340, 160, 110, 110],\n\t\t\t[ 215, 160, 100, 110],\n\t\t\t[  85, 160, 100, 110],\n\n\t\t\t[ 735,  40, 100,  95],\n\t\t\t[ 610,  40,  90,  90],\n\t\t\t[ 485,  45,  80,  85],\n\t\t\t[ 355,  50,  80,  75],\n\t\t\t[ 230,  50,  75,  70],\n\t\t\t[ 105,  59,  55,  51]\n\n\t\t];\n\t};\n\n\n\tdraw(ctx, pos) {\n\t\tif (this.index === 0) this.sound.play();\n\t\t\n\t\tif (this.index < this.sheet.length) {\n\t\t\tctx.drawImage(this.img, \n\t\t\t\tthis.sheet[this.index][0], this.sheet[this.index][1], this.sheet[this.index][2], this.sheet[this.index][3],\n\t\t\t\tpos[0]-this.index/2,\n\t\t\t\tpos[1] - 5-this.index/2,\n\t\t\t\t15+this.index,\n\t\t\t\t15+this.index\n\t\t\t);\n\n\t\t\tthis.index++;\n\t\t}\n\t\t\n\t\treturn this.index\n\t};\n}\n\nmodule.exports = Explosion;\n\n//# sourceURL=webpack:///./src/explosion.js?");

/***/ }),

/***/ "./src/fire.js":
/*!*********************!*\
  !*** ./src/fire.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Fire {\n\tconstructor(img) {\n\t\tthis.imageSheet = img;\n\n\t\tthis.trailCounter = 0;\n\t\tthis.trailCountMax = 40;\n\t\tthis.trailPoints = new Array(this.trailCountMax);\n\n\t\tthis.width = 12;\n\n\t\tthis.spriteIndex = 0;\n\t\tthis.sheet = [\n\t\t\t[40,115],\n\t\t\t[147,115],\n\t\t\t[255,115],\n\t\t\t[361,115],\n\t\t\t[467,115],\n\t\t\t[40,208],\n\t\t\t[147,208],\n\t\t\t[255,208],\n\t\t\t[361,208],\n\t\t\t[467,208]\n\t\t];\n\t};\n\n\n\tgetWidth() { return this.width; };\n\n\tdraw(ctx, pos, shiftDir) {\n\t\tthis.drawFlames(ctx, pos);\n\t\tthis.drawTrail(ctx, pos, shiftDir);\n\t};\n\n\t\n\t// cycle through sprite sheet to draw flames\n\tdrawFlames(ctx, pos) {\n\t\tctx.drawImage(\n\t\t\tthis.imageSheet,\n\t\t\tthis.sheet[this.spriteIndex][0],\n\t\t\tthis.sheet[this.spriteIndex][1],\n\t\t\t90, 90,\n\t\t\tpos.x, pos.y,\n\t\t\tthis.width, this.width\n\t\t);\n\n\t\tthis.spriteIndex++;\n\t\tif (this.spriteIndex === 10) this.spriteIndex = 0;\n\t};\n\n\n\t// keeps an array with adjusted locations of the fire to create a fiery trail\n\tdrawTrail(ctx, pos, shiftDir) {\n\n\t\t// add current location (overwriting oldest) for trail in array implementing queue\n\t\tthis.trailPoints[this.trailCounter] =\n\t\t\t{ x: pos.x + this.width / 2, y: pos.y + this.width / 2 };\n\n\t\tlet i = this.trailCounter + 6;\n\t\tif (i >= this.trailCountMax) i = i % this.trailCountMax;\n\n\t\tlet count = 0;\n\t\twhile (i !== this.trailCounter) {\n\n\t\t\t// shift all points to account for screen shifting that keeps main ship\n\t\t\t// in the center\n\t\t\tif (this.trailPoints[i]) {\n\t\t\t\tthis.trailPoints[i].x -= shiftDir.x * shiftDir.speed;\n\t\t\t\tthis.trailPoints[i].y += shiftDir.y * shiftDir.speed;\n\n\t\t\t\tctx.beginPath();\n\n\t\t\t\t// lightness and radius trail off toward the end of the tail\n\t\t\t\tctx.fillStyle = \"hsl(0, 100%,\" + count / this.trailCountMax * 100 + \"%)\";\n\t\t\t\tctx.arc(this.trailPoints[i].x, this.trailPoints[i].y,\n\t\t\t\t\t2 * count / this.trailCountMax, 0, 2 * Math.PI);\n\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t\tcount++;\n\t\t\ti++;\n\t\t\tif (i >= this.trailCountMax) i = i % this.trailCountMax;\n\t\t}\n\n\t\tthis.trailCounter++;\n\t\tif (this.trailCounter === this.trailCountMax) this.trailCounter = 0;\n\t};\n\n};\nmodule.exports = Fire;\n\n\n//# sourceURL=webpack:///./src/fire.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Star = __webpack_require__(/*! ./non-ship_space_objects/star */ \"./src/non-ship_space_objects/star.js\");\nconst Planet = __webpack_require__(/*! ./non-ship_space_objects/planet */ \"./src/non-ship_space_objects/planet.js\");\nconst Torpedo = __webpack_require__(/*! ./non-ship_space_objects/torpedo */ \"./src/non-ship_space_objects/torpedo.js\");\nconst BridgeView = __webpack_require__(/*! ./bridge_view */ \"./src/bridge_view.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nclass Game {\n\n\tconstructor(images) {\n\t\tthis.images = images;\n\n\t\tthis.base_speed_inverse = 5;\n\n\t\tthis.win = false;\n\t\tthis.lose = false;\n\t\tthis.muted = false;\n\t\tthis.autopilot = false;\n\n\t\tthis.enemies = [];\n\t\tthis.allies = [];\n\t\tthis.torpedoes = [];\n\n\t\tthis.keyMap = {};\n\n\t\tthis.torpedoKey = 0;\n\n\t\tthis.stars = new Array(250);\n\t\tfor (let i = 0; i < this.stars.length; i++) {\n\t\t\tconst starData = Utils.createStarData(Utils.getCanvasDim().x, Utils.getCanvasDim().y);\n\t\t\tthis.stars[i] = new Star(starData);\n\t\t};\n\t\t\t\n\t\tthis.turnCounter = 0;\n\t\tthis.turnCounterMax = 8;\n\t\tthis.bridgeView = new BridgeView(images);\n\t}\n\n\tgetKeyMap() { return this.keyMap; };\n\tgetBridge() { return this.bridgeView; };\n\n\taddMainShip(ship) {\tthis.main = ship;\t};\n\taddEnemy(enemy) { this.enemies.push(enemy); };\n\taddAlly(ship) { this.allies.push(ship); };\n\n\n\t// factory method to create planet and moon objects\n\tcreatePlanetAndMoon(planetImg, pCoords, moonImg, mCoords = [3, 3, 58, 58]) {\n\t\tthis.planet = new Planet({\n\t\t\tpos: [300, 300],\n\t\t\timg: planetImg,\n\t\t\twidth: 200, height: 200,\n\t\t\tsheetCoords: pCoords\n\t\t});\n\n\t\tthis.moon_01 = new Planet({\n\t\t\tpos: [260, 410],\n\t\t\timg: moonImg,\n\t\t\twidth: 50, height: 50,\n\t\t\tsheetCoords: mCoords\n\t\t});\n\t};\n\n\n\tstep() {\n\t\t// gets user input\n\t\tthis.turnCounter++;\n\t\tif (this.turnCounter === this.turnCounterMax) {\n\t\t\tthis.turnCounter = 0;\n\t\t\tthis.checkKeyMap();\n\t\t}\n\t\telse if (this.turnCounter % 2 === 0) this.checkKeyMap();\n\n\t\tthis.moveObjects();\n\n\t\tthis.enemies.forEach((enemy) => enemy.consultAI(enemy.onscreen()));\n\t\tthis.allies.forEach((ally) => ally.consultAI(ally.onscreen()));\n\n\t\tif (this.autopilot && this.main.getTarget())\n\t\t\tthis.main.consultAI(this.main.getTarget().onscreen());\n\n\t\tthis.checkTorpCollisions();\n\n\t\tthis.bridgeView.step();\n\t};\n\n\n\tmoveObjects() {\n\t\tthis.shift();\n\n\t\t// now give ships and objects their own movement\n\t\tthis.enemies.forEach((enemy) => enemy.move(this.base_speed_inverse));\n\n\t\tthis.allies.forEach((ally) => ally.move(this.base_speed_inverse));\n\n\t\tthis.moveTorpedos();\n\t};\n\n\n\t// shift moves everything but main ship to show main ship's movement\n\tshift() {\n\t\tconst shift = this.main.getShift();\n\n\t\tconst shift_x = shift.x / this.base_speed_inverse;\n\t\tconst shift_y = shift.y / this.base_speed_inverse;\n\n\t\tthis.stars.forEach((star) =>\n\t\t\tstar.shift([shift_x, shift_y], shift.speed));\n\n\t\tthis.enemies.forEach((enemy) => enemy.shift([shift_x, shift_y], shift.speed));\n\t\tthis.allies.forEach((ally) => ally.shift([shift_x, shift_y], shift.speed));\n\n\t\t// the planet and moon shift differently than the stars to give a layered background\n\t\tthis.planet.shift(\n\t\t\t[shift.x / (this.base_speed_inverse - 2),\n\t\t\tshift.y / (this.base_speed_inverse - 2)],\n\t\t\tshift.speed);\n\n\t\tthis.moon_01.shift(\n\t\t\t[shift.x / (this.base_speed_inverse - 2.25),\n\t\t\tshift.y / (this.base_speed_inverse - 2.25)],\n\t\t\tshift.speed);\n\t};\n\n\n\tdraw(ctx) {\n\t\t// clear canvas and draw black background\n\t\tctx.beginPath();\n\t\tctx.clearRect(0, 0, Utils.getCanvasDim().x, Utils.getCanvasDim().y);\n\t\tctx.fillStyle = \"black\";\n\t\tctx.fillRect(0, 0, Utils.getCanvasDim().x, Utils.getCanvasDim().y);\n\n\t\t// draw all of the objects\n\t\tthis.stars.forEach((star) => star.draw(ctx));\n\t\tthis.planet.draw(ctx);\n\t\tthis.moon_01.draw(ctx);\n\t\tthis.torpedoes.forEach((torpedo) => torpedo.draw(ctx));\n\n\t\tthis.main.draw(ctx);\n\n\t\tthis.enemies.forEach((enemy) => {\n\t\t\tif (this.enemies.length > 1) enemy.draw(ctx, enemy === this.main.getTarget());\n\t\t\telse enemy.draw(ctx);\n\t\t});\n\n\t\tthis.allies.forEach((ally) => ally.draw(ctx));\n\n\t\t// draw mute and autopilot box\n\t\tthis.drawCheckBox(ctx, 20, 30, \"Mute\", this.muted);\n\t\tthis.drawCheckBox(ctx, 20, 70, \"Autopilot\", this.autopilot);\n\n\t\tthis.bridgeView.draw(ctx);\n\n\t\tif (this.main.getTarget() && !this.main.getTarget().onscreen()) \n\t\t\tthis.drawTargetArrow(ctx);\n\n\t\tif (this.lose) this.drawMessage(ctx, \"Sorry, your ship exploded\");\n\t\tif (this.win) this.drawMessage(ctx, \"Congratulations, You Win!\");\n\t};\n\n\n\tdrawMessage(ctx, message) {\n\t\tctx.font = \"72px FINALOLD\";\n\t\tctx.fillStyle = \"#FAFAD2\";\n\n\t\tctx.fillText(message, Utils.getCanvasDim().x / 2 - 315,\n\t\t\tUtils.getCanvasDim().y / 3 - 100);\n\t\tctx.fillText(\"Click to play again\", Utils.getCanvasDim().x / 2 - 240, \n\t\t\tUtils.getCanvasDim().y / 3 - 20);\n\t};\n\n\n\t// draws the mute and autopilot check boxes\t\n\tdrawCheckBox(ctx, x, y, label, check) {\n\t\tctx.beginPath();\n\t\tctx.rect(x, y, 20, 20);\n\t\tctx.strokeStyle = \"white\";\n\t\tctx.lineWidth = 3;\n\t\tctx.stroke();\n\n\t\tctx.font = \"24px Arial\";\n\t\tctx.fillStyle = \"white\";\n\t\tctx.fillText(label, x + 30, y + 18);\n\n\t\tif (check) {\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + 10);\n\t\t\tctx.lineTo(x + 10, y + 20);\n\t\t\tctx.lineTo(x + 25, y);\n\t\t\tctx.strokeStyle = 'red';\n\t\t\tctx.lineWidth = 5;\n\t\t\tctx.stroke();\n\t\t}\n\t};\n\n\n\t// if the main ship's target is offscreen, draws an arrow\n\tdrawTargetArrow(ctx) {\n\n\t\tconst angle = Utils.findAngle(this.main.center(), this.main.getTarget().center());\n\t\tconst arrowLength = 80;\n\t\tconst upperLeftAngle = 3.741045138431531;\n\t\tconst upperRightAngle = 5.6837328223378485;\n\t\tconst lowerRightAngle = .6848212459426003;\n\t\tconst lowerLeftAngle = 2.4567714076471927;\n\n\t\tconst deltaX = this.main.getTarget().center()[0] - this.main.center()[0];\n\t\tconst deltaY = this.main.getTarget().center()[1] - this.main.center()[1];\n\n\t\tlet endPoint = [0,0];\n\t\tlet startPoint = [0,0]; \n\n\t\tif (angle >= upperRightAngle || angle < lowerRightAngle) {\n\t\t\tendPoint[0] = 1200;\n\t\t\tendPoint[1] = this.main.center()[1] + \n\t\t\t\t(1200 - this.main.center()[0])/deltaX  * deltaY;\n\t\t} \n\t\telse if (angle >= lowerRightAngle && angle < lowerLeftAngle) {\n\t\t\tendPoint[1] = 900;\n\t\t\tendPoint[0] = this.main.center()[0] + \n\t\t\t\t(900 - this.main.center()[1]) / deltaY * deltaX;\n\t\t}\n\t\telse if (angle >= lowerLeftAngle && angle < upperLeftAngle){\n\t\t\tendPoint[0] = 0;\n\t\t\tendPoint[1] = this.main.center()[1] - this.main.center()[0] / deltaX * deltaY;\t\n\t\t}\n\t\telse {\n\t\t\tendPoint[1] = 0;\n\t\t\tendPoint[0] = this.main.center()[0] - this.main.center()[1] / deltaY * deltaX;\t\n\t\t}\n\n\t\tconst distance = Utils.distance(this.main.center(), endPoint);\n\t\tconst offsetRatio =  (distance - arrowLength) / distance;\n\t\t\n\t\tfor(let i = 0; i < 2; i++) {\n\t\t\tstartPoint[i] = (endPoint[i] - this.main.center()[i]) * offsetRatio + \n\t\t\t\tthis.main.center()[i];\n\t\t}\n\n\t\tUtils.drawTarget(ctx, startPoint[0], startPoint[1], 5, 2);\n\t\tthis.drawArrow(ctx, startPoint, endPoint, angle);\n\t};\n\n\n\tdrawArrow(ctx, startPoint, endPoint, angle, color = \"red\", width = 3, \n\t\theadEdgeLength = 30, headAngle = Math.PI/9) {\n\n\t\tctx.lineWidth = width;\n\t\tctx.strokeStyle = color;\n\t\t// const angle = Utils.findAngle(startPoint, endPoint);\n\n\t\t// this draws the main body of the arrow\n\t\tctx.beginPath();\n\t\tctx.moveTo(startPoint[0], startPoint[1]);\n\t\tctx.lineTo(endPoint[0], endPoint[1]);\n\n\t\tconst headEdgeAngle1 = angle + headAngle;\n\t\tconst headEdgeAngle2 = angle - headAngle;\n\n\t\tlet xOffset = Math.cos(headEdgeAngle1) * headEdgeLength;\n\t\tlet yOffset = Math.sin(headEdgeAngle1) * headEdgeLength;\n\n\t\t// this draws one edge of the arrowhead\n\t\tctx.lineTo(endPoint[0] - xOffset, endPoint[1] - yOffset);\n\t\tctx.moveTo(endPoint[0], endPoint[1]);\n\n\t\txOffset = Math.cos(headEdgeAngle2) * headEdgeLength;\n\t\tyOffset = Math.sin(headEdgeAngle2) * headEdgeLength;\n\n\t\t// this draws the other edge of the arrowhead\n\t\tctx.lineTo(endPoint[0] - xOffset, endPoint[1] - yOffset);\n\t\tctx.stroke();\n\t}\n\t\n\n\tmuteToggle(gainNode) {\n\t\tthis.muted = this.muted === false;\n\t\tif (gainNode.gain.value > -.01 && gainNode.gain.value < .01) gainNode.gain.value = .25;\n\t\telse gainNode.gain.value = 0;\n\t};\n\n\n\tautoPilotToggle() {\n\t\tthis.autopilot = this.autopilot === false;\n\t};\n\n\n\tmoveTorpedos() {\n\t\tthis.torpedoes.forEach((torpedo, i) => {\n\t\t\ttorpedo.move();\n\n\t\t\t// delete torpedo when it moves offscreen\n\t\t\tlet center = torpedo.center();\n\t\t\tif (center[0] < 0 || center[0] > Utils.getCanvasDim().x ||\n\t\t\t\tcenter[1] < 0 || center[1] > Utils.getCanvasDim().y)\n\t\t\t\tthis.torpedoes.splice(i, 1);\n\t\t});\n\t};\n\n\n\tfireTorpedoes(ship) {\n\t\tif (ship.fireTorpedos()) {\n\t\t\t\n\t\t\tthis.torpedoes.push(new Torpedo(ship, this.images, this.torpedoKey,\n\t\t\t\tship.calcDirection(ship.getRotation() - Math.PI / 18)));\n\n\t\t\tthis.torpedoes.push(new Torpedo(ship, this.images, this.torpedoKey,\n\t\t\t\tship.getDirection()));\n\n\t\t\tthis.torpedoes.push(new Torpedo(ship, this.images, this.torpedoKey,\n\t\t\t\tship.calcDirection(ship.getRotation() + Math.PI / 18)));\n\n\t\t\tthis.torpedoKey++;\n\t\t\tif (this.torpedoKey === 100) this.torpedoKey = 0;\n\t\t}\n\t};\n\n\n\tfirePhasers(ship) {\n\t\tconst enemyOnScreen = this.main.getTarget().onscreen();\n\t\tif ((ship === this.main && enemyOnScreen) ||\n\t\t\t(ship !== this.main && ship.onscreen()))\n\t\t\tship.firePhasers();\n\t};\n\n\n\tcheckTorpCollisions() {\n\t\tconst ships = this.enemies.concat(this.main).concat(this.allies);\n\n\t\tthis.torpedoes.forEach((torpedo, i) => {\n\t\t\tships.forEach((ship) => {\n\t\t\t\tif (ship.isEnemy() !== torpedo.getLauncher().isEnemy() \n\t\t\t\t\t&& Utils.distance(ship.center(), torpedo.center()) < 30) {\n\t\t\t\t\tship.receiveTorpHit(torpedo);\n\t\t\t\t\tthis.torpedoes.splice(i, 1);\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t};\n\n\n\tchangeMainTarget() {\n\t\tlet newIdx = 0;\n\t\tthis.enemies.forEach((enemy, i) => {\n\t\t\tif (enemy === this.main.getTarget()) newIdx = i + 1;\n\t\t})\n\t\tif (newIdx === this.enemies.length) newIdx = 0;\n\t\tthis.main.setTarget(this.enemies[newIdx]);\n\t};\n\n\n\t// returns a new target\n\trandomTarget(ship) {\n\t\tlet potentialTargets = [];\n\n\t\tif (ship.isEnemy()) potentialTargets = this.allies.concat(this.main);\n\t\telse potentialTargets = this.enemies;\n\n\t\tconst targets = potentialTargets.concat([]);\n\n\t\t// eliminates offscreen targets\n\t\ttargets.forEach((target,i) => { if (!target.onscreen()) targets.splice(i,1)});\n\n\t\n\t\tif (targets.length > 0) return targets[Math.floor(Math.random() * targets.length)];\n\t\telse if (!ship.getTarget() || (!ship.isEnemy() && ship.getTarget() === this.main))\n\t\t\treturn potentialTargets[Math.floor(Math.random() * potentialTargets.length)];\n\t\telse return ship.target;\n\t};\n\n\n\tcheckKeyMap() {\n\t\t// spacebar\n\t\tif (this.keyMap[\"32\"]) this.firePhasers(this.main);\n\n\t\t// t\n\t\tif (this.keyMap[\"84\"] && this.turnCounter === 0) this.changeMainTarget();\n\n\t\t// f or k\n\t\tif (this.keyMap[\"75\"] || this.keyMap[\"70\"]) this.fireTorpedoes(this.main);\n\n\t\t// w or up arrow\n\t\tif ((this.keyMap[\"87\"] || this.keyMap[\"38\"]) && this.turnCounter === 0)\n\t\t\tthis.main.power(.5);\n\n\t\t// s or down arrow\n\t\tif ((this.keyMap[\"83\"] || this.keyMap[\"40\"]) && this.turnCounter === 0)\n\t\t\tthis.main.power(-.5);\n\n\t\t// a or left arrow\n\t\tif (this.keyMap[\"65\"] || this.keyMap[\"37\"]) this.main.changeDirection(-1);\n\n\t\t// d or right arrow\n\t\tif (this.keyMap[\"68\"] || this.keyMap[\"39\"]) this.main.changeDirection(1);\n\t};\n\n}\n\nmodule.exports = Game;\n\n//# sourceURL=webpack:///./src/game.js?");

/***/ }),

/***/ "./src/game_opening.js":
/*!*****************************!*\
  !*** ./src/game_opening.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\nconst SolarSystem = __webpack_require__(/*! ./solarSystem/solar_system */ \"./src/solarSystem/solar_system.js\");\nconst SSData1 = __webpack_require__(/*! ./solarSystem/ss_data1 */ \"./src/solarSystem/ss_data1.js\");\n\nclass GameOpening {\n\n\tconstructor(ctx) {\n\t\tthis.canvas_width = Utils.getCanvasDim().x;\n\t\tthis.canvas_height = Utils.getCanvasDim().y;\n\t\tthis.shipChoice = true;\n\t\tthis.scenario = false;\n\t\tthis.userDraw = null;\n\t\tthis.max_depth = 32;\n\n\t\tthis.centerOfSS = { x: Utils.getCanvasDim().x / 2, y: 145 };\n\t\tthis.ss = new SolarSystem(150, 340);\n\t\tSSData1.addDataToSS(this.ss, this.centerOfSS,);\n\n\t\tthis.stars = new Array(512);\n\n\t\tthis.createOpeningStarfield();\n\n\t\t// this.logoImg = Utils.loadImg('./images/st-logo.png');\n\n\t\tthis.sillyImg = Utils.loadImg('./images/sillyDrawing.png');\n\t\tthis.enterImg = Utils.loadImg('./images/uss-enterprise-png-choice.png');\n\n\t\tthis.bopScenImg = Utils.loadImg('./images/scenarios/bops_scenario.png');\n\t\tthis.d7ScenImg = Utils.loadImg('./images/scenarios/D7_scenario.png');\n\t\tthis.fleetScenImg = Utils.loadImg('./images/scenarios/fleet_scenario.png');\n\t};\n\n\tsetUserDraw(ud) { this.userDraw = ud; }\n\tgetUserDraw() { return this.userDraw; }\n\n\tgetShipChoice() { return this.shipChoice; }\n\tsetShipChoice(choice) { this.shipChoice = choice; }\n\n\tgetScenario() { return this.scenario; }\n\tsetScenario(scen) { this.scenario = scen; }\n\n\t// a version of the starfield came from http://codentronix.com/2011/07/22/html5-canvas-3d-starfield/\n\tcreateOpeningStarfield() {\n\t\tfor (let i = 0; i < this.stars.length; i++) {\n\t\t\tthis.stars[i] = {\n\t\t\t\tx: this.randomRange(-32, 32),\n\t\t\t\ty: this.randomRange(-32, 32),\n\t\t\t\tz: this.randomRange(1, this.max_depth)\n\t\t\t};\n\t\t};\n\t};\n\n\n\tstepAndDraw(ctx) {\n\t\tconst halfWidth = this.canvas_width / 2;\n\t\tconst halfHeight = this.canvas_height / 2;\n\n\t\tctx.clearRect(0, 0, Utils.getCanvasDim().x, Utils.getCanvasDim().y);\n\t\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\tctx.fillRect(0, 0, Utils.getCanvasDim().x, Utils.getCanvasDim().y);\n\n\t\tif (this.scenario) {\n\t\t\t// ctx.drawImage(this.logoImg, 60, 0, 450, 512, 294, 25, 700, 850);\n\t\t\tthis.ss.step();\n\t\t\tthis.ss.draw(ctx);\n\t\t\tthis.drawScenario(ctx);\n\t\t} \n\t\telse {\n\t\t\tthis.stars.forEach((star) => {\n\t\t\t\tstar.z -= 0.1;\n\n\t\t\t\tif (star.z <= 0) {\n\t\t\t\t\tstar.x = this.randomRange(-32, 32);\n\t\t\t\t\tstar.y = this.randomRange(-32, 32);\n\t\t\t\t\tstar.z = this.max_depth;\n\t\t\t\t}\n\n\t\t\t\tconst k = 128.0 / star.z;\n\t\t\t\tconst px = star.x * k + halfWidth;\n\t\t\t\tconst py = star.y * k + halfHeight;\n\n\t\t\t\tif (px >= 0 && px <= this.canvas_width && py >= 0 && py <= this.canvas_height) {\n\t\t\t\t\tconst size = (1 - star.z / 32.0) * 5;\n\t\t\t\t\tconst shade = parseInt((1 - star.z / 32.0) * 255);\n\t\t\t\t\tctx.fillStyle = \"rgb(\" + shade + \",\" + shade + \",\" + shade + \")\";\n\t\t\t\t\tctx.fillRect(px, py, size, size);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (this.shipChoice) this.drawShipChoice(ctx);\n\t\telse if (this.getUserDraw()) this.userDraw.draw();\n\t};\n\n\n\trandomRange(minVal, maxVal) {\n\t\treturn Math.floor(Math.random() * (maxVal - minVal - 1)) + minVal;\n\t};\n\n\n\tdrawScenario(ctx) {\n\n\t\tctx.drawImage(this.d7ScenImg, 0, 0, 350, 350,  37, 450,  350, 350);\n\t\tctx.drawImage(this.bopScenImg, 0, 0, 350, 350, 424, 450, 350, 350);\n\t\tctx.drawImage(this.fleetScenImg, 0, 0, 350, 350, 813, 450, 350, 350);\n\n\t\tctx.beginPath();\n\n\t\tctx.rect(37, 450, 350, 350);\n\t\tctx.rect(424, 450, 350, 350);\n\t\tctx.rect(813, 450, 350, 350);\n\n\t\tctx.strokeStyle = \"grey\";\n\t\tctx.lineWidth = 3;\n\t\tctx.stroke();\n\n\t\tctx.fillStyle = \"lightblue\";\n\t\tctx.font = \"80px FINALOLD\";\n\t\tctx.fillText(\"Now Click a Scenario Below\", 250, 400);\n\n\t\tctx.font = \"44px FINALOLD\";\n\t\tctx.fillText(\"Fight a Cruiser\", 110, 865);\n\t\tctx.fillText(\"2 Smaller Birds of Prey\", 428, 865);\n\t\tctx.fillText(\"or in a Fleet Action\", 850, 865);\n\t};\n\n\n\tdrawShipChoice(ctx) {\n\t\tconst y = 540;\n\t\tconst x1 = 130;\n\t\tconst x2 = 780;\n\n\t\tctx.fillStyle = \"lightblue\";\n\n\t\tctx.font = \"132px FINALOLD\";\n\t\tctx.fillText(\"The Picard Maneuver\", \n\t\t\tthis.canvas_width / 2 - 435, \n\t\t\tthis.canvas_height /3-30);\n\n\t\tctx.font = \"72px FINALOLD\";\n\t\tctx.fillText(\"A Tactical Starship Combat Game\", \n\t\t\tthis.canvas_width / 2 - 380, \n\t\t\tthis.canvas_height / 3+ 50);\n\n\t\tctx.fillStyle = \"#FAFAD2\";\n\n\t\tctx.font = \"54px FINALOLD\"; \n\t\tctx.fillText(\"Play as This Ship\", x1, y);\n\t\tctx.fillText(\"Doodle Your Own Ship\", x2-40, y);\n\n\n\t\tctx.fillText(\"Click Here!\", x1+50, y + 240);\n\t\tctx.fillText(\"Click Here!\", x2+60 , y + 240);\n\n\t\tctx.fillStyle = \"lightblue\";\n\t\tctx.font = \"72px FINALOLD\";\n\t\tctx.fillText(\"OR\", 570, y+135);\n\n\t\tctx.drawImage(this.enterImg, 22, 0, 660, 300, x1, y + 28, 300, 150);\n\t\tctx.drawImage(this.sillyImg, 0, 50, 490, 350, x2, y+2, 300, 200);\n\t}\n}\n\nmodule.exports = GameOpening;\n\n//# sourceURL=webpack:///./src/game_opening.js?");

/***/ }),

/***/ "./src/game_view.js":
/*!**************************!*\
  !*** ./src/game_view.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Game = __webpack_require__(/*! ./game */ \"./src/game.js\");\nconst GameOpening = __webpack_require__(/*! ./game_opening */ \"./src/game_opening.js\");\nconst UserDraw = __webpack_require__(/*! ./user_draw */ \"./src/user_draw.js\");\nconst DrawnShip = __webpack_require__(/*! ./ships/drawn_ship */ \"./src/ships/drawn_ship.js\");\nconst Enterprise = __webpack_require__(/*! ./ships/enterprise */ \"./src/ships/enterprise.js\");\nconst Soyuz = __webpack_require__(/*! ./ships/soyuz */ \"./src/ships/soyuz.js\");\nconst D7 = __webpack_require__(/*! ./ships/d7 */ \"./src/ships/d7.js\");\nconst Bird_of_Prey = __webpack_require__(/*! ./ships/bird_of_prey */ \"./src/ships/bird_of_prey.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nclass GameView {\n\tconstructor(ctx, audioCtx, sounds) {\n\n\t\tthis.ctx = ctx;\n\t\tthis.audioCtx = audioCtx;\n\t\tthis.sounds = sounds;\n\t\tthis.pause = false;\n\n\t\t// main ship is the default\n\t\tthis.enterprise = true;\n\n\t\tthis.images = this.loadImages();\n\t\tthis.game = new Game(this.images);\n\t\tthis.gameOpening = new GameOpening(ctx);\n\t\tthis.demo = false;\n\t};\n\t\n\n\tstart() {\n\t\t// start the animation\n\t\trequestAnimationFrame(this.animate.bind(this));\n\t};\n\n\n\tanimate() {\n\t\tif (!this.pause) {\n\n\t\t\t// if unpaused this steps and draws either the game or the gameOpening\n\t\t\tif (this.gameOpening !== null) this.gameOpening.stepAndDraw(this.ctx);\n\t\t\telse {\n\t\t\t\tif (this.demo && (this.game.main.isGone() || this.game.enemies.length === 0)) {\n\t\t\t\t\tconst muted = this.game.muted;\n\t\t\t\t\tthis.game = new Game(this.images);\n\t\t\t\t\tthis.loadScenario4();\n\t\t\t\t\tthis.game.muted = muted;\n\t\t\t\t}\n\t\t\t\telse if (this.game.main.getHull() === 0) this.game.lose = true;\n\t\t\t\telse if (this.game.enemies.length === 0) this.game.win = true;\n\t\t\t\telse {\n\t\t\t\t\tthis.game.enemies.forEach((enemy, i) => {\n\t\t\t\t\t\tif (enemy.isGone()){\n\t\t\t\t\t\t\tthis.game.enemies.splice(i, 1);\n\t\t\t\t\t\t\t\n \t\t\t\t\t\t\tif(this.game.main.getTarget() === enemy) this.game.changeMainTarget();\n\t\t\t\t\t\t\tif(this.game.enemies.length > 0) \n\t\t\t\t\t\t\t\tthis.game.enemies[this.game.enemies.length - 1].setLabels(true);\n\t\t\t\t\t\t} \n\t\t\t\t\t})\n\t\t\t\t\tthis.game.allies.forEach((ally, i) => {\n\t\t\t\t\t\tif (ally.isGone()) this.game.allies.splice(i, 1);\n\t\t\t\t\t})\n\t\t\t\t\tthis.game.step();\n\t\t\t\t}\n\t\t\t\tthis.game.draw(this.ctx);\n\t\t\t}\n\t\t\t// every call to animate requests causes another call to animate\n\t\t\trequestAnimationFrame(this.animate.bind(this));\n\t\t}\n\t};\n\n\t\n\tkeyHandler(e) {\n\t\tif (e.type == 'keydown') this.game.getKeyMap()[e.keyCode] = true;\n\t\telse this.game.getKeyMap()[e.keyCode] = false;\t\t\t\n\t};\n\n\t// get ship choice, \n\t// get clicks for choices on draw screen\n\t// get scenario click if still in the opening of the game,\n\t// check to see if mute or autopilot is being clicked\n\tcheckClick(e, gainNode) {\n\t\tconst x = e.pageX;\n\t\tconst y = e.pageY;\n\n\t\tif (this.gameOpening !== null) {\n\t\t\tif (this.gameOpening.getShipChoice()) this.chooseShip(x,y);\n\t\t\telse if(this.gameOpening.getUserDraw() != null) this.drawingClick(x,y);\n\t\t\telse this.chooseScenario(x,y,gainNode);\t\n\t\t}\n\t\t// start again from scenario choice\t\n\t\telse if (this.game.win || this.game.lose) {\n\t\t\tthis.game = new Game(this.images);\n\t\t\tthis.gameOpening = new GameOpening(this.ctx);\n\t\t\tthis.gameOpening.setShipChoice(false);\n\t\t\tthis.gameOpening.setScenario(true);\n\t\t}\n\t\telse {\n\t\t\tthis.muteAndAutopilotBoxes(x,y,gainNode);\n\t\t}\n\t};\n\n\n\tdrawingClick(x,y) {\n\t\tif (x >= 517 && x <= 731 && y >= 818 && y <= 872) { // accept button\n\t\t\tthis.gameOpening.getUserDraw().acceptDrawing();\n\t\t\tthis.drawing = this.gameOpening.getUserDraw().getDrawing();\n\t\t\tthis.ssdPortrait = this.gameOpening.getUserDraw().getSSDportrait();\n\t\t\t\n\t\t\tthis.gameOpening.setShipChoice(false);\n\t\t\tthis.gameOpening.setScenario(true);\n\t\t\tthis.enterprise = false;\n\n\t\t\tthis.gameOpening.setUserDraw(null);\n\t\t}\n\t\telse if (x >= 298 && x <= 330) this.gameOpening.getUserDraw().changeColor(y);\n\t\telse if (x >= 896 && x <= 1013)\tthis.gameOpening.getUserDraw().changeLineWidth(y);\n\t\t\n\t};\n\n\tpauseGameToggle() {\n\t\tthis.pause = this.pause === false;\n\t\t\n\t\t// needed to restart animation on unpause\n\t\tif (!this.pause) this.start();\n\t};\n\n\n\topeningOff() {\n\t\tthis.gameOpening = null;\n\t\tthis.audioCtx.resume().then(() => { return true; });\n\t\tthis.sounds.theme.play();\n\t};\n\t\n\n\tmuteAndAutopilotBoxes(x, y, gainNode){\n\t\tif (x > 35 && x < 65) {\n\t\t\tif (y > 46 && y < 71) {\n\t\t\t\tthis.game.muteToggle(gainNode);\n\n\t\t\t\t// if paused, draw to show checkmark in box\n\t\t\t\tif (this.pause) this.game.draw(this.ctx)\n\t\t\t}\n\t\t\telse if (y > 85 && y < 112) {\n\t\t\t\tthis.game.autoPilotToggle();\n\n\t\t\t\t// if paused, draw to show checkmark in box\n\t\t\t\tif (this.pause) this.game.draw(this.ctx)\n\t\t\t}\n\t\t}\n\t};\n\n\n\tchooseShip(x,y) {\n\t\tif (y >= 517 && y <= 803) {\n\t\t\tif (x >= 150 && x <= 444) {\n\t\t\t\tthis.gameOpening.setShipChoice(false);\n\t\t\t\tthis.gameOpening.setScenario(true);\n\t\t\t\tthis.enterprise = true;\n\t\t\t}\n\t\t\telse if (x >= 760 && x <= 1133) {\n\t\t\t\tthis.gameOpening.setShipChoice(false);\n\t\t\t\tthis.gameOpening.setUserDraw(new UserDraw(this.ctx));\n\t\t\t}\n\t\t}\n\t};\n\n\n\tchooseScenario(x,y,gainNode) {\n\t\tif (y >= 467 && y <= 884) {\n\t\t\tif (x > 54 && x < 407) {\n\t\t\t\tthis.loadScenario1();\n\t\t\t\tthis.openingOff();\n\t\t\t\tgainNode.gain.value = .25;\n\t\t\t}\n\t\t\telse if (x > 440 && x < 795) {\n\t\t\t\tthis.loadScenario2();\n\t\t\t\tthis.openingOff();\n\t\t\t\tgainNode.gain.value = .25;\n\t\t\t}\n\t\t\telse if (x > 830 && x < 1184) {\n\t\t\t\tthis.loadScenario3();\n\t\t\t\tthis.openingOff();\n\t\t\t\tgainNode.gain.value = .25;\n\t\t\t}\n\t\t}\n\t\t// continuous demo mode\n\t\telse if (x > 20 && y > 20 && x < 40 && y < 40) {\n\t\t\tthis.game.muteToggle(gainNode);\n\t\t\tthis.loadScenario4();\n\t\t\tthis.openingOff();\n\t\t}\n\t};\n\n\t\n\tloadScenario1(){\n\t\tthis.game.createPlanetAndMoon(this.images.planet_08, [0, 0, 480, 480],\n\t\t\tthis.images.moon_01 );\n\n\t\t// this.addShip([shipXpos, shipYpos],[ssdXpos, ssdYpos, ssdScale, ssdLabels], aiTargeting, rotation, phaserRecharge, torpedoReload)\n\t\tthis.addMain([1040, 710, 1, true], false, Math.PI, 0, 0);\n\t\tthis.addD7([0, 100], [100, 710, 1, true], false, 0, 0, 0);\n\t\t// this.addSoyuz([0, 100], [100, 710, 1, true], false, 0, 0, 0);\n\n\t\tthis.game.main.setTarget(this.game.enemies[0]);\n\t};\n\n\n\tloadScenario2() {\n\t\tthis.game.createPlanetAndMoon(this.images.planet_03, [0, 0, 480, 480], \n\t\t\tthis.images.moon_01);\n\n\t\t// this.addShip([shipXpos, shipYpos],[ssdXpos, ssdYpos, ssdScale, ssdLabels], aiTargeting, rotation, phaserRecharge, torpedoReload)\n\t\tthis.addMain([1040, 710, 1, true], false, Math.PI, 0, 0);\n\t\tthis.addBop([0, 400], [100, 630, .6, false], true, 0, 80, 100);\n\t\tthis.addBop([0, 100], [100, 775, .6, true], true, 0, 0, 0);\n\n\t\tthis.game.main.setTarget(this.game.enemies[0]);\n\t};\n\n\n\tloadScenario3() {\n\t\tthis.game.createPlanetAndMoon(this.images.moon_03, [0, 0, 110, 110], \n\t\t\tthis.images.moon_01);\n\n\t\t// this.addShip([shipXpos, shipYpos],[ssdXpos, ssdYpos, ssdScale, ssdLabels], aiTargeting, rotation, phaserRecharge, torpedoReload)\n\t\tthis.addMain([1060, 765, .7, true], true, Math.PI);\n\t\tthis.addSoyuz([600, 350], [1064, 475, .6, false], true, Math.PI);\n\t\tthis.addSoyuz([600, 450], [1064, 618, .6, false], true, Math.PI,50,50);\n\t\tthis.addBop([0, 300], [104, 475, .6, false], true, 0, 80, 100);\n\t\tthis.addBop([0, 100], [104, 618, .6, false], true, 0);\n\t\tthis.addD7([0, 200], [100, 765, .7, true], true, .1*Math.PI,80);\n\n\t\tthis.game.main.setTarget(this.game.randomTarget(this.game.main));\n\t};\n\n\tloadScenario4() {\n\t\tthis.loadScenario3();\n\t\tthis.demo = true;\n\t\tthis.game.autoPilotToggle();\n\t};\n\n\n\taddMain(ssdPos, aiTargeting, rotationOffset, phaserRecharge, torpedoReload) {\n\t\tconst options = {\n\t\t\tgame: this.game,\n\t\t\tssdPos,\n\t\t\trotationOffset,\n\t\t\timages: this.images,\n\t\t\tsounds: this.sounds,\n\t\t\tphaserRecharge,\n\t\t\ttorpedoReload,\n\t\t\taiTargeting,\n\t\t\tbridgeView: this.game.getBridge()\n\t\t}\n\n\t\tif (this.enterprise) this.game.addMainShip(new Enterprise(options));\n\t\telse \n\t\t\tthis.game.addMainShip(new DrawnShip(options, this.drawing, this.ssdPortrait));\n\t}\n\t\n\n\n\taddBop(pos, ssdPos, aiTargeting, rotationOffset, phaserRecharge, torpedoReload) {\n\t\tthis.game.addEnemy(new Bird_of_Prey({\n\t\t\tgame: this.game,\n\t\t\tpos, ssdPos,\n\t\t\trotationOffset,\n\t\t\timages: this.images,\n\t\t\tsounds: this.sounds,\n\t\t\tphaserRecharge,\n\t\t\ttorpedoReload,\n\t\t\taiTargeting\n\t\t}));\n\t};\n\n\taddSoyuz(pos, ssdPos, aiTargeting, rotationOffset, phaserRecharge, torpedoReload) {\n\t\tthis.game.addAlly(new Soyuz({\n\t\t\tgame: this.game,\n\t\t\tpos, ssdPos,\n\t\t\trotationOffset,\n\t\t\timages: this.images,\n\t\t\tsounds: this.sounds,\n\t\t\tphaserRecharge,\n\t\t\ttorpedoReload,\n\t\t\taiTargeting\n\t\t}));\n\t};\n\n\taddD7(pos, ssdPos, aiTargeting, rotationOffset, phaserRecharge, torpedoReload) {\n\t\tthis.game.addEnemy(new D7({\n\t\t\tgame: this.game,\n\t\t\tpos, ssdPos,\n\t\t\trotationOffset,\n\t\t\timages: this.images,\n\t\t\tsounds: this.sounds,\n\t\t\tphaserRecharge,\n\t\t\ttorpedoReload, \n\t\t\taiTargeting\n\t\t}));\n\t};\n\n\n\tloadImages() {\n\t\treturn {\n\t\t\tbopSsdImg: Utils.loadImg('./images/ssds/bop-ssd.png'),\n\t\t\td7SsdImg: Utils.loadImg('./images/ssds/d7-ssd.png'),\n\t\t\tsoyuzSsdImg: Utils.loadImg('./images/ssds/soyuz-ssd2.png'),\n\t\t\tentSsdImg: Utils.loadImg('./images/ssds/enterprise-ssd.png'),\n\t\t\tsparksImg: Utils.loadImg('./images/sparks.png'),\n\t\t\texplosionImg: Utils.loadImg('./images/explosion-sprite-sheet.png'),\n\t\t\tbopImg: Utils.loadImg('./images/ships/bop.png'),\n\t\t\td7Img: Utils.loadImg('./images/ships/D7.png'),\n\t\t\tsoyuzImg: Utils.loadImg('./images/ships/soyuz.png'),\n\t\t\tenterpriseImg: Utils.loadImg('./images/ships/uss-enterprise-png-view-original-669.png'),\n\t\t\ttorpImg: Utils.loadImg('./images/torpedo.png'),\n\t\t\tkTorpImg: Utils.loadImg('./images/many_torpedos.png'),\t\t\n\t\t\tmoon_01: Utils.loadImg('./images/planets/moon_01.png'),\n\t\t\tmoon_03: Utils.loadImg('./images/planets/moon_03.png'),\n\t\t\tplanet_08: Utils.loadImg('./images/planets/planet_08.png'),\n\t\t\tplanet_03: Utils.loadImg('./images/planets/planet_03.png'),\n\t\t\tbridge: Utils.loadImg('./images/bridge.png'),\n\t\t\tbridgeShaken: Utils.loadImg('./images/bridge_shaken.png'),\n\t\t\ttorpIcon: Utils.loadImg('./images/torpIcon.png'),\n\t\t\tfireImg: Utils.loadImg('./images/sprite-sheet-fire.png'),\n\t\t}\n\t};\n}\n\nmodule.exports = GameView;\n\n//# sourceURL=webpack:///./src/game_view.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const GameView = __webpack_require__(/*! ./game_view */ \"./src/game_view.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n\tconst canvasEl = document.getElementsByTagName(\"canvas\")[0];\n\tcanvasEl.width = Utils.getCanvasDim().x;\n\tcanvasEl.height = Utils.getCanvasDim().y;\n\tconst ctx = canvasEl.getContext(\"2d\");\n\n\t// sounds\n\tconst audioCtx = new AudioContext();\n\tconst gainNode = audioCtx.createGain();\n\tgainNode.gain.value = .25;\n\n\tlet gv = new GameView(ctx, audioCtx, {\n\t\t\tphasSound: getSound(\"phaser\", audioCtx, gainNode), \n\t\t\tdisruptSound: getSound(\"disruptor\", audioCtx, gainNode), \n\t\t\tdisrupt2Sound: getSound(\"disruptor2\", audioCtx, gainNode), \n\t\t\tkTorpSound: getSound(\"klingonTorpedo\", audioCtx, gainNode), \n\t\t\ttorpSound: getSound(\"torpedo\", audioCtx, gainNode),\t\n\t\t\texploSound: getSound(\"explosion\", audioCtx, gainNode), \n\t\t\ttheme: getSound(\"theme\", audioCtx, gainNode)\n\t});\n\n\tgv.start();\n\n\t// this block is for the events for the user to draw a ship\n\tcanvasEl.addEventListener('mousedown', () => { \n\t\tif (gv.gameOpening && gv.gameOpening.getUserDraw()) \n\t\t\tgv.gameOpening.getUserDraw().setMouseDown(true); \n\t});\n\tcanvasEl.addEventListener('mousemove', (e) => {\n\t\tif (gv.gameOpening && gv.gameOpening.getUserDraw() \n\t\t\t&& gv.gameOpening.getUserDraw().getMouseDown()) \n\t\t\t\tgv.gameOpening.getUserDraw().drawFromUser(e);\n\t});\n\tcanvasEl.addEventListener('mouseup', () => {\n\t\tif (gv.gameOpening && gv.gameOpening.getUserDraw()) {\n\t\t\tgv.gameOpening.getUserDraw().setMouseDown(false);\n\t\t\tgv.gameOpening.getUserDraw().endLine();\n\t\t}\n\t});\n\n\n\tcanvasEl.addEventListener(\"click\", (e) => {\n\t\tgv.checkClick(e, gainNode);\n\t\t// console.log(\"x = \" + e.offsetX, \"y = \" + e.offsetY);\n\t\t// console.log(\"x = \" + e.pageX, \"y = \" + e.pageY);\n\n\t});\n\n\n\twindow.addEventListener('keydown', (e) => {\n\n\t\tif (e.target == document.body) {\n\t\t\tswitch (e.keyCode) {\n\t\t\t\tcase 80:\n\t\t\t\t\tif (!gv.gameOpening) gv.pauseGameToggle(); // p pauses game\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32: case 37: case 38: case 39: case 40:\n\t\t\t\t// stops the spacebar and arrow keys from moving window\n\t\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t}\n\n\t\tgv.keyHandler(e);\n\t\t\n\t});\n\n\n\twindow.addEventListener('keyup', (e) => {\n\t\tgv.keyHandler(e);\n\t});\n});\n\nfunction getSound(id, audioCtx, gainNode) { \n\tconst sound = document.getElementById(id);\n\tconst track = audioCtx.createMediaElementSource(sound);\n\ttrack.connect(gainNode).connect(audioCtx.destination);\n\treturn sound;\n};\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/non-ship_space_objects/planet.js":
/*!**********************************************!*\
  !*** ./src/non-ship_space_objects/planet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const SpaceObject = __webpack_require__(/*! ./space_object */ \"./src/non-ship_space_objects/space_object.js\");\n\nclass Planet extends SpaceObject {\n\tconstructor(options) {\n\t\tsuper(options.pos);\n\t\tthis.img = options.img;\n\t\tthis.width = options.width;\n\t\tthis.height = options.height;\n\t\tthis.sheetCoords = options.sheetCoords;\n\t}\n\n\tdraw(ctx) {\n\t\tctx.drawImage(this.img,\n\t\t\tthis.sheetCoords[0], this.sheetCoords[1], this.sheetCoords[2], this.sheetCoords[3],\n\t\t\tthis.pos[0], this.pos[1], this.width, this.height);\n\t}\n}\n\nmodule.exports = Planet;\n\n//# sourceURL=webpack:///./src/non-ship_space_objects/planet.js?");

/***/ }),

/***/ "./src/non-ship_space_objects/space_object.js":
/*!****************************************************!*\
  !*** ./src/non-ship_space_objects/space_object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass SpaceObject {\n\tconstructor(pos) {\n\t\tif (pos) this.pos = pos;\n\t\tthis.direction = {x:0,y:0};\n\t\tthis.width;\n\t\tthis.height;\n\t};\n\n\n\tmove(base_speed_inverse) {\n\t\tthis.pos[0] += (this.direction.x / base_speed_inverse) * this.speed;\n\t\tthis.pos[1] -= (this.direction.y / base_speed_inverse) * this.speed;\n\t};\n\n\n\t// shifts to account for main ship movement\n\tshift(direction, speed) {\n\t\tthis.pos[0] -= speed * direction[0];\n\t\tthis.pos[1] += speed * direction[1];\n\t};\n\n\n\tonscreen() {\n\t\tconst center = this.center();\n\t\treturn (center[0] > 0 && center[0] < Utils.getCanvasDim().x &&\n\t\t\tcenter[1] > 0 && center[1] < Utils.getCanvasDim().y);\n\t};\n\n\t \n\tcenter() {\n\t\treturn [this.pos[0] + this.width / 2, this.pos[1] + this.height / 2];\n\t};\n\n}\n\nmodule.exports = SpaceObject\n\n//# sourceURL=webpack:///./src/non-ship_space_objects/space_object.js?");

/***/ }),

/***/ "./src/non-ship_space_objects/star.js":
/*!********************************************!*\
  !*** ./src/non-ship_space_objects/star.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const SpaceObject = __webpack_require__(/*! ./space_object */ \"./src/non-ship_space_objects/space_object.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass Star extends SpaceObject {\n\tconstructor(options){\n\t\tsuper(options.pos);\n\n\t\tthis.radius = options.radius;\n\t\tthis.hue = options.hue;\n\t\tthis.sat = options.sat;\n\t};\n\n\n\tdraw(ctx) {\n\t\tconst fillStyle = \"hsl(\" + this.hue + \", \" + this.sat + \"%, 88%)\";\n\t\tUtils.drawFilledCircle(ctx, this.pos[0], this.pos[1], this.radius, fillStyle);\n\t};\n\t\n\t\n\tshift(direction, speed) {\n\t\tsuper.shift(direction, speed);\n\n\t\tif (this.pos[0] > Utils.getCanvasDim().x) this.pos[0] = 0;\n\t\telse if (this.pos[0] < 0) this.pos[0] = Utils.getCanvasDim().x;\n\n\t\tif (this.pos[1] > Utils.getCanvasDim().y) this.pos[1] = 0;\n\t\telse if (this.pos[1] < 0) this.pos[1] = Utils.getCanvasDim().y;\n\t};\n\n}\n\nmodule.exports = Star;\n\n//# sourceURL=webpack:///./src/non-ship_space_objects/star.js?");

/***/ }),

/***/ "./src/non-ship_space_objects/torpedo.js":
/*!***********************************************!*\
  !*** ./src/non-ship_space_objects/torpedo.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const SpaceObject = __webpack_require__(/*! ./space_object */ \"./src/non-ship_space_objects/space_object.js\");\n\nclass Torpedo extends SpaceObject {\n\tconstructor(launcher, images, key, direction) {\n\t\tsuper(launcher.center());\n\n\t\tthis.launcher = launcher;\n\t\tthis.direction = direction;\n\t\tthis.images = images;\n\t\tthis.key = key;\n\n\t\tif (launcher.isEnemy()) {\n\t\t\tthis.torpImg = this.images.kTorpImg;\n\t\t\tthis.dim = [249, 137, 79, 78];\n\t\t}\n\t\telse {\n\t\t\tthis.torpImg = this.images.torpImg\n\t\t\tthis.dim = [0, 0, 44, 46];\n\t\t}\n\n\t\tthis.speed = 3;\n\t\tthis.height = 10;\n\t\tthis.width = 10;\n\t};\n\t\n\tgetLauncher() { return this.launcher; }\n\tgetKey() {return this.key; }\n\t\n\tdraw(ctx) {\n\t\tctx.drawImage(this.torpImg, \n\t\t\tthis.dim[0], this.dim[1], this.dim[2], this.dim[3],\n\t\t\tthis.pos[0]-this.width/2,\n\t\t\tthis.pos[1]-this.height/2,\n\t\t\tthis.width,\n\t\t\tthis.height);\n\t};\n\n\n\tmove() {\n\t\tthis.pos[0] += this.speed * this.direction.x;\n\t\tthis.pos[1] -= this.speed * this.direction.y;\n\t};\n\n};\n\nmodule.exports = Torpedo;\n\n\n//# sourceURL=webpack:///./src/non-ship_space_objects/torpedo.js?");

/***/ }),

/***/ "./src/shield.js":
/*!***********************!*\
  !*** ./src/shield.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Shield {\n\tconstructor(options) {\n\t\tthis.pos = options.pos;\n\t\tthis.start = options.start;\n\t\tthis.end = options.end;\n\t\tthis.radius = options.radius;\n\n\t\tthis.maxHitpoints = options.shieldStrength;\n\t\tthis.hitpoints = this.maxHitpoints;\n\t\tthis.color = \"#ADD8E6\";\n\t\tthis.timer = 0;\n\t}\n\n\tgetHitpoints() { return this.hitpoints; }\n\n\tup() { return this.hitpoints > 0; }\n\n\n\tdraw(ctx, scale) {\n\t\tthis.timer++;\n\t\tif (this.timer === 40) {\n\t\t\tthis.timer = 0;\n\t\t\tthis.color = \"#ADD8E6\";\n\t\t}\n\n\t\tlet shieldPercentage = this.hitpoints / this.maxHitpoints;\n\n\t\tctx.beginPath();\n\n\t\tif (this.hitpoints > 0) { // have to do this check because of a mysterious bug when user would draw ship\n\t\t\tctx.arc(this.pos[0], \n\t\t\t\tthis.pos[1], \n\t\t\t\tthis.radius, \n\t\t\t\tthis.start * Math.PI + (this.end - this.start)/2* Math.PI * (1 - shieldPercentage),\n\t\t\t\tthis.end * Math.PI - (this.end - this.start)/2 * Math.PI * (1 - shieldPercentage)\n\t\t\t);\n\t\t\n\t\t\tctx.lineWidth = 3 + 4*scale*this.maxHitpoints/100;\n\t\t\tctx.strokeStyle = this.color;\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\n\thit(damage) {\n\t\tthis.timer = 1;\n\t\tthis.color = \"red\";\n\n\t\tthis.hitpoints -= damage;\n\t\tif (this.hitpoints < 0) this.hitpoints = 0;\n\t}\n}\n\nmodule.exports = Shield;\n\n//# sourceURL=webpack:///./src/shield.js?");

/***/ }),

/***/ "./src/ships/bird_of_prey.js":
/*!***********************************!*\
  !*** ./src/ships/bird_of_prey.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Frigate = __webpack_require__(/*! ./frigate */ \"./src/ships/frigate.js\");\nconst SSD = __webpack_require__(/*! ../ssd */ \"./src/ssd.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass Bird_of_Prey extends Frigate {\n\tconstructor(options) {\n\t\tsuper(options);\n\n\t\tthis.enemy = true;\n\n\t\tthis.shipImg = { \n\t\t\timage: this.images.bopImg, x: 0, y: 0, width: 267, height: 300 };\n\n\t\tthis.width = 30;\n\t\tthis.height = 40;\n\n\t\tthis.beamSound = options.sounds.disrupt2Sound;\n\t\tthis.torpSound = options.sounds.kTorpSound;\n\n\t\tthis.engineDamageDim = {left_x: 27, right_x: 35, y: 90, width: 8, height: 15};\n\t\tthis.beamDamageDim = { left_x: -25, right_x: 92, y: 45, width: 3, height: 25 };\n\t\tthis.torpImgOnSSD = { x: 30, y: 15 };\n\n\t\tthis.engineFireLoc = { angle: .95 * Math.PI, distance: 12 };\n\t\tthis.beamFireLoc = { angle: 1.5 * Math.PI, distance: 18 };\n\t\tthis.torpFireLoc = { angle: 0, distance: 10 };\n\t\t\n\t\tthis.callbacks = {\n\t\t\tbeamDrawCB: Utils.drawLine,\n\t\t\tengineDamCB: Utils.drawRect,\n\t\t\tbeamDamCB: Utils.drawRect\n\t\t};\n\n\t\tthis.phaserRechargeMax = 170;\n\t\tthis.torpedoReloadMax = 200;\n\n\t\tthis.phaserColor = \"green\";\n\n\t\tthis.phaserOffsetDistance = 20;\n\t\tthis.phaserOffsetAngle = 1.6*Math.PI;\n\n\t\tthis.phaserDamage = 10;\n\t\tthis.hullIntegrityMax = 100;\n\t\tthis.hullIntegrity = this.hullIntegrityMax;\n\n\t\t// ssd is the ship systems display in the corner of the screen\n\t\tthis.ssd = new SSD({\n\t\t\tssdPos: options.ssdPos,\n\t\t\timg_size: [120,100],\n\t\t\timg_pos_offset: [-25, 12],\n\t\t\timg: this.images.bopSsdImg,\n\t\t\tbeamWeaponName: 'Disruptor',\n\t\t\timgCoords: [0, 0, 350, 240],\n\t\t\tshieldStrength: 45,\n\t\t});\n\t};\n};\n\nmodule.exports = Bird_of_Prey;\n\n//# sourceURL=webpack:///./src/ships/bird_of_prey.js?");

/***/ }),

/***/ "./src/ships/d7.js":
/*!*************************!*\
  !*** ./src/ships/d7.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ship = __webpack_require__(/*! ./ship */ \"./src/ships/ship.js\");\nconst SSD = __webpack_require__(/*! ../ssd */ \"./src/ssd.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass D7 extends Ship {\n\tconstructor(options) {\n\t\tsuper(options);\n\n\t\tthis.enemy = true;\n\n\t\tthis.shipImg = {\n\t\t\timage: this.images.d7Img, x: 0, y: 0, width: 380, height: 275 };\n\t\t\t\n\t\tthis.turnRadius = 2;\n\n\t\tthis.beamSound = options.sounds.disruptSound;\n\t\tthis.torpSound = options.sounds.kTorpSound;\n\n\t\tthis.engineDamageDim = {left_x: 0, right_x: 66, y: 82, width: 3, height: 32};\n\t\tthis.beamDamageDim = { left_x: 1, right_x: 67, y: 77, width: 7, height: 4 };\n\t\tthis.torpImgOnSSD = { x: 30, y: 5 };\n\n\t\tthis.engineFireLoc = { angle: 1.16 * Math.PI, distance: 27 };\n\t\tthis.beamFireLoc = { angle: .78 * Math.PI, distance: 18 };\n\t\tthis.torpFireLoc = { angle: 0, distance: 25 };\n\n\t\tthis.callbacks = {\n\t\t\tbeamDrawCB: Utils.drawWavyLine,\n\t\t\tengineDamCB: Utils.drawRect,\n\t\t\tbeamDamCB: Utils.drawEllipse\n\t\t};\n\n\t\tthis.width = 60;\n\t\tthis.height = 30;\n\n\t\tthis.phaserRechargeMax = 200;\n\t\tthis.torpedoReloadMax = 190;\n\n\t\tthis.phaserColor = \"green\";\n\t\tthis.phaserOffsetDistance = 16;\n\n\t\t// ssd is the ship systems display in the corner of the screen\n\t\tthis.ssd = new SSD({\n\t\t\tssdPos: options.ssdPos,\n\t\t\timg_size: [75, 114],\n\t\t\timg_pos_offset: [-3, 3],\n\t\t\timg: this.images.d7SsdImg,\n\t\t\tbeamWeaponName: 'Disruptor',\n\t\t\timgCoords: [0, 0, 207, 287],\n\t\t\tshieldStrength: 100,\n\t\t});\n\t};\n\n\n\t// when beam is drawn, it could be drawn from either side depending on where target it\n\tfirePhasers() {\n\t\tconst angle = Utils.angleToOtherShip(this, this.target);\n\t\tif (angle <= Math.PI) this.phaserOffsetAngle = .7 * Math.PI;\n\t\telse this.phaserOffsetAngle = 1.3 * Math.PI;\n\n\t\tsuper.firePhasers();\n\t}\n}\n\n\nmodule.exports = D7;\n\n//# sourceURL=webpack:///./src/ships/d7.js?");

/***/ }),

/***/ "./src/ships/drawn_ship.js":
/*!*********************************!*\
  !*** ./src/ships/drawn_ship.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MainShip = __webpack_require__(/*! ./main_ship */ \"./src/ships/main_ship.js\");\nconst SSD = __webpack_require__(/*! ../ssd */ \"./src/ssd.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass DrawnShip extends MainShip {\n\tconstructor(options, drawing, ssdImg) {\n\t\tsuper(options);\n\n\t\tthis.shipImg = { image:drawing, x: 1, y: 1, width: 498, height: 498 };\n\n\t\tthis.enemy = false;\n\n\t\tthis.width = 50;\n\t\tthis.height = 50;\n\n\t\tthis.beamSound = options.sounds.phasSound;\n\t\tthis.torpSound = options.sounds.torpSound;\n\n\t\tthis.engineDamageDim = { left_x: 7, right_x: 60, y: 78, width: 3, height: 35 };\n\t\tthis.beamDamageDim = { left_x: 34, right_x: 34, y: 22, width: 7, height: 4 };\n\t\tthis.torpImgOnSSD = { x: 30, y: 50 };\n\n\t\tthis.engineFireLoc = { angle: 1.18 * Math.PI, distance: 18 };\n\t\tthis.beamFireLoc = { angle: 0, distance: 20 };\n\t\tthis.torpFireLoc = { angle: 0, distance: 0 };\n\n\t\tthis.callbacks = {\n\t\t\tbeamDrawCB: Utils.drawLine,\n\t\t\tengineDamCB: Utils.drawRect,\n\t\t\tbeamDamCB: Utils.drawEllipse\n\t\t};\n\n\t\tthis.phaserColor = \"red\";\n\n\t\t// ssd is the ship systems display in the corner of the screen\n\t\tthis.ssd = new SSD({\n\t\t\tssdPos: options.ssdPos,\n\t\t\timg_size: [100, 100],\n\t\t\timg_pos_offset: [-15, 14],\n\t\t\timg: ssdImg,\n\t\t\tbeamWeaponName: \"Phaser\",\n\t\t\timgCoords: [0, 0, 500, 500],\n\t\t\tshieldStrength: 100,\n\t\t});\n\t};\n};\n\nmodule.exports = DrawnShip;\n\n//# sourceURL=webpack:///./src/ships/drawn_ship.js?");

/***/ }),

/***/ "./src/ships/enterprise.js":
/*!*********************************!*\
  !*** ./src/ships/enterprise.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Main = __webpack_require__(/*! ./main_ship */ \"./src/ships/main_ship.js\");\nconst SSD = __webpack_require__(/*! ../ssd */ \"./src/ssd.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass Enterprise extends Main {\n\tconstructor(options) {\n\t\tsuper(options);\n \n\t\tthis.enemy = false;\n\n\t\tthis.shipImg = {\n\t\t\timage: this.images.enterpriseImg, x:22, y:0, width:660, height:300 };\n\n\t\tthis.beamSound = options.sounds.phasSound;\n\t\tthis.torpSound = options.sounds.torpSound;\n\n\t\tthis.engineDamageDim = {left_x: 13, right_x: 52, y: 68, width: 4, height: 53};\n\t\tthis.beamDamageDim = { left_x: 34, right_x: 34, y: 22, width: 7, height: 4 };\n\t\tthis.torpImgOnSSD = {x: 30, y: 50};\n\n\t\tthis.engineFireLoc = { angle: .86 * Math.PI, distance: 25 };\n\t\tthis.beamFireLoc = { angle: 0, distance: 20 };\n\t\tthis.torpFireLoc = { angle: 0, distance: 0 };\n\n\t\tthis.callbacks = { \n\t\t\tbeamDrawCB: Utils.drawLine, \n\t\t\tengineDamCB: Utils.drawRect,\n\t\t\tbeamDamCB: Utils.drawEllipse };\n\n\t\tthis.width = 60;\n\t\tthis.height = 30;\n\t\t\n\t\t// phaser animation starts from middle of saucer instead of center of ship\n\t\tthis.phaserOffsetDistance = 18;\n\t\tthis.phaserColor = \"red\";\n\n\t\t// ssd is the ship systems display in the corner of the screen\n\t\tthis.ssd = new SSD({\n\t\t\tssdPos: options.ssdPos,\n\t\t\timg_size: [60, 120],\n\t\t\timg_pos_offset: [5,4],\n\t\t\timg: this.images.entSsdImg,\n\t\t\tbeamWeaponName: \"Phaser\",\n\t\t\timgCoords: [0, 0, 110, 257],\n\t\t\tshieldStrength: 100,\n\t\t});\n\t};\n}\n\n\nmodule.exports = Enterprise\n\n//# sourceURL=webpack:///./src/ships/enterprise.js?");

/***/ }),

/***/ "./src/ships/frigate.js":
/*!******************************!*\
  !*** ./src/ships/frigate.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ship = __webpack_require__(/*! ./ship */ \"./src/ships/ship.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass Frigate extends Ship {\n\tconstructor(options) {\n\t\tsuper(options);\n\t\tthis.beamPattern = [3, 5, 3, 20];\n\t\tthis.turnRadius = 1;\n\t};\n\n\n\tdraw(ctx, target){\n\t\tsuper.draw(ctx, target)\n\n\t\t// fires a 2nd disruptor line from other wing\n\t\tif (this.phaserCounter > 0 && this.ptarget && !this.ptarget.isGone())\n\t\t\tthis.drawPhaser(ctx, 2 * Math.PI - this.phaserOffsetAngle, 0);\n\t};\n\n\n\t// frigate can only fire beams if target is in front\n\tfirePhasers() {\n\t\tconst angle = Utils.angleToOtherShip(this, this.target)\n\t\tif ((angle > (2 * Math.PI - Math.PI / 9)) || (angle < Math.PI / 9)) super.firePhasers();\n\t}\n}\n\nmodule.exports = Frigate;\n\n//# sourceURL=webpack:///./src/ships/frigate.js?");

/***/ }),

/***/ "./src/ships/main_ship.js":
/*!********************************!*\
  !*** ./src/ships/main_ship.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ship = __webpack_require__(/*! ./ship */ \"./src/ships/ship.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass MainShip extends Ship {\n\tconstructor(options) {\n\t\tsuper(options);\n\n\t\tthis.turnRadius = 2;\n\n\t\tthis.pos = [\n\t\t\tUtils.getCanvasDim().x / 2 - this.width/2, \n\t\t\tUtils.getCanvasDim().y / 2 - this.height/2 - 40];\n\n\t\tthis.bridgeView = options.bridgeView;\n\t};\n\n\n\tgetShift() {\n\t\t// this is saved for the main ship for the damage fire trail in class Fire\n\t\tthis.shiftDir = {\n\t\t\tx: this.getDirection().x, \n\t\t\ty: this.getDirection().y, \n\t\t\tspeed: this.getSpeed() / 4};\n\n\t\treturn {\n\t\t\tx: this.getDirection().x,\n\t\t\ty: this.getDirection().y,\n\t\t\tspeed: this.getSpeed()};\n\t};\n\n\n\ttakeDamage(attacker, damage) {\n\t\tthis.bridgeView.shakeOn();\n\t\tlet returnValue = super.takeDamage(attacker, damage);\n\n\t\t// if (this.engineDamCount === 1) this.bridgeView.enginDamBubbleOn();\n\t\t// else if (this.beamDamCount === 1) this.bridgeView.beamDamBubbleOn();\n\t\t// else if (this.torpDamCount === 1) this.bridgeView.torpDamBubbleOn();\n\t\treturn returnValue;\n\t};\n\n\n\tdraw(ctx, beamCallback, engineDamCallback, beamDamCallback, shipImage) {\n\t\tif (this.shipExplosionCounter == 1) this.bridgeView.destroyed();\n\t\tsuper.draw(ctx, beamCallback, engineDamCallback, beamDamCallback, shipImage);\n\t};\n\n\tfirePhasers(){\n\t\tlet returnValue = super.firePhasers();\n\t\tif (returnValue) this.bridgeView.phasersBubbleOn();\n\t\treturn returnValue;\n\t};\n\n\tfireTorpedos() {\n\t\tlet returnValue = super.fireTorpedos();\n\t\tif (returnValue) this.bridgeView.torpedosBubbleOn();\n\t\treturn returnValue;\n\t};\n};\n\nmodule.exports = MainShip;\n\n//# sourceURL=webpack:///./src/ships/main_ship.js?");

/***/ }),

/***/ "./src/ships/ship.js":
/*!***************************!*\
  !*** ./src/ships/ship.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const SpaceObject = __webpack_require__(/*! ../non-ship_space_objects/space_object */ \"./src/non-ship_space_objects/space_object.js\");\nconst Explosion = __webpack_require__(/*! ../explosion */ \"./src/explosion.js\");\nconst Fire = __webpack_require__(/*! ../fire */ \"./src/fire.js\");\nconst EnemyAI = __webpack_require__(/*! ../enemyAI */ \"./src/enemyAI.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass Ship extends SpaceObject{\n\n\tconstructor(options) {\n\t\tsuper(options.pos);\n\n\t\tif (options.rotationOffset) this.rotationOffset = options.rotationOffset;\n\t\telse this.rotationOffset = 0;\n\t\t\n\t\tthis.images = options.images;\n\t\tthis.target = options.target;\n\t\t\n\t\tthis.AI = new EnemyAI(this, options.game, options.aiTargeting);\n\n\t\tthis.explosion = new Explosion(this.images.explosionImg, options.sounds.exploSound);\n\n\t\tthis.engineFire = null;\n\t\tthis.beamFire = null;\n\t\tthis.torpFire = null;\n\n\t\tthis.beamPattern = [];\n\n\t\tthis.shiftDir = { x: 0, y: 0, speed: 0 };\n\n\t\tthis.speed = 0;\n\t\tthis.width = 60; \t\t// height and width need to be here\n\t\tthis.height = 30;\n\t\tthis.phaserOffsetDistance = 0;\n\t\tthis.phaserOffsetAngle = 0;\n\t\tthis.phaserCounter = 0;\n\t\tthis.torpExplosionCounter = 0;\n\t\tthis.shipExplosionCounter = 0;\n\t\tthis.phaserDamage = 18;\n\t\tthis.torpedoDamage = 20;\n\t\tthis.targetShieldHP = 1;\n\t\tthis.ssdPos = options.ssdPos;\n\n\t\tthis.engineDamCount = 0;\n\t\tthis.beamDamCount = 0; \n\t\tthis.torpDamCount = 0;\n\t\tthis.damageCountMax = 480;\n\n\t\tthis.direction = this.calcDirection(this.rotationOffset);\n\n\t\tthis.ssd;\n\t\tthis.damageTokens = [];\n\n\t\tif (options.phaserRecharge) this.phaserRecharge = options.phaserRecharge;\n\t\telse this.phaserRecharge = 0;\n\t\tthis.phaserRechargeMax = 180;\n\n\t\tif (options.torpedoReload) this.torpedoReload = options.torpedoReload;\n\t\telse this.torpedoReload = 0;\n\t\tthis.torpedoReloadMax= 220;\n\n\t\tthis.hullIntegrityMax = 200;\n\t\tthis.hullIntegrity = this.hullIntegrityMax;\n\t};\n\n\t// getter methods\n\tgetDirection() { return this.direction; }\n\tgetSpeed() { return this.speed; }\n\tgetRotation() { return this.rotationOffset; }\n\tgetSSD() { return this.ssd; }\n\tphaserReady() { return this.phaserRecharge === this.phaserRechargeMax; }\n\ttorpedosReady() { return this.torpedoReload >= this.torpedoReloadMax; }\n\tgetHull() { return this.hullIntegrity; }\n\tgetTarget() { return this.target; }\n\tgetTurnRadius() { return this.turnRadius; }\n\tgetTorpedoDamage() { return this.torpedoDamage; }\n\tisGone() { return this.shipExplosionCounter >= 33; }\n\tisEnemy() { return this.enemy; }\n\n\t// setter methods\n\tsetTarget(target) { this.target = target; }\n\tsetLabels(val) { this.ssd.setLabels(val); }\n\t\n\n\t// shifts to account for main ship movement\n\tshift(direction, speed) {\n\n\t\t// saves the shift to apply to damage fire trail in class Fire\n\t\tthis.shiftDir = { x: direction[0], y: direction[1], speed: speed };\n\n\t\tsuper.shift(direction, speed);\n\t};\n\n\n\tdraw(ctx, target) {\n\t\tthis.drawShip(ctx);\n\n\t\t//draw ship systems display\n\t\tthis.drawSSD(ctx, target);\n\n\t\t// if there are multiple enemies, the current target gets a target draw on on it\n\t\tif (target) Utils.drawTarget(ctx, this.center()[0], this.center()[1], 7,1);\n\n\t\tif (this.phaserCounter > 0 && this.ptarget && !this.ptarget.isGone())\n\t\t\tthis.drawPhaser(ctx, this.phaserOffsetAngle, this.phaserDamage);\n\n\t\t// recharge weapons\n\t\tif (this.phaserRecharge !== this.phaserRechargeMax) this.phaserRecharge++;\n\t\tif (this.torpedoReload < this.torpedoReloadMax) this.torpedoReload++;\n\n\t\t//shows torpedo hit\n\t\tif (this.torpExplosionCounter) {\n\t\t\tthis.drawTorpExplosion(ctx);\n\t\t\tthis.torpExplosionCounter++;\n\t\t\tif (this.torpExplosionCounter > 15) this.torpExplosionCounter = 0;\n\t\t}\n\n\t\tif (this.damageTokens.length > 0) this.drawDamageTokens(ctx);\n\n\t\t// displays plasma fires resulting from system damage\n\t\tif (this.engineFire) this.drawDamageFire(ctx, this.engineFire, this.engineFireLoc); \n\t\tif (this.beamFire) this.drawDamageFire(ctx, this.beamFire, this.beamFireLoc); \n\t\tif (this.torpFire) this.drawDamageFire(ctx, this.torpFire, this.torpFireLoc); \n\n\t\tif (this.hullIntegrity === 0) this.shipExplosionCounter = this.drawShipExplosion(ctx);\n\t};\n\n\n\tdrawShip(ctx){\n\t\tctx.save();\n\n\t\t// rotate\n\t\tctx.translate(this.center()[0], this.center()[1]);\n\t\tctx.rotate(this.rotationOffset);\n\t\tctx.translate(-(this.center()[0]), -(this.center()[1]));\n\n\t\t//draw ship\n\t\tif (this.shipExplosionCounter < 34) {\n\t\t\tctx.drawImage(this.shipImg.image, this.shipImg.x, this.shipImg.y, \n\t\t\t\tthis.shipImg.width, this.shipImg.height,\n\t\t\t\tthis.pos[0], this.pos[1], this.width, this.height);\n\t\t}\n\n\t\tctx.restore();\n\t};\n\n\n\tdrawSSD(ctx, engineDamCallback, beamDamCallback, target) {\n\t\tthis.ssd.draw(ctx,\n\t\t\tthis.phaserRecharge / this.phaserRechargeMax,\n\t\t\tthis.torpedoReload / this.torpedoReloadMax,\n\t\t\tthis.hullIntegrity / this.hullIntegrityMax,\n\t\t\ttarget\n\t\t);\n\n\t\tthis.drawEngineDamageOnSSD(ctx);\n\t\tthis.drawBeamDamageOnSSD(ctx);\n\t\tthis.drawTorpDamageOnSSD(ctx);\n\t};\n\n\n\tdrawEngineDamageOnSSD(ctx) {\n\t\tif (this.engineDamCount === this.damageCountMax) {\n\t\t\tthis.engineDamCount = 0;\n\t\t\tthis.engineFire = null;\n\t\t}\n\t\telse if (this.engineDamCount > 0) {\n\t\t\tconst ratio = this.engineDamCount / this.damageCountMax;\n\t\t\tthis.engineDamCount++;\n\t\t\tthis.ssd.drawDamageLabel(ctx, \"Repairing Engines\", 0, ratio);\n\n\t\t\tif (this.engineDamCount % 40 > 10) {\n\t\t\t\tthis.ssd.drawSysDamageOnSSD(ctx, this.engineDamageDim, \n\t\t\t\t\tthis.callbacks.engineDamCB);\n\t\t\t}\n\t\t}\n\t};\n\n\n\tdrawBeamDamageOnSSD(ctx, callback) {\n\t\tif (this.beamDamCount === this.damageCountMax) {\n\t\t\tthis.beamDamCount = 0;\n\t\t\tthis.beamFire = null;\n\t\t\tthis.phaserDamage = this.phaserDamage * 2;\n\t\t}\n\t\telse if (this.beamDamCount > 0) {\n\t\t\tconst ratio = this.beamDamCount / this.damageCountMax;\n\t\t\tthis.beamDamCount++;\t\n\t\t\tthis.ssd.drawDamageLabel(ctx, \"Repairing \" + this.ssd.getBeamName() + \"s\", \n\t\t\t\t50, ratio);\n\n\t\t\tif (this.beamDamCount % 40 > 10) {\n\t\t\t\tthis.ssd.drawSysDamageOnSSD(ctx, this.beamDamageDim, \n\t\t\t\t\tthis.callbacks.beamDamCB);\t\n\t\t\t}\n\t\t}\n\t};\n\n\n\tdrawTorpDamageOnSSD(ctx) {\n\t\tif (this.torpDamCount === this.damageCountMax) {\n\t\t\tthis.torpDamCount = 0;\n\t\t\tthis.torpFire = null;\n\t\t\tthis.torpedoReloadMax = this.torpedoReloadMax / 2;\n\n\t\t\tif (this.torpedoReload > this.torpedoReloadMax)\n\t\t\t\tthis.torpedoReload = this.torpedoReloadMax;\n\t\t}\n\t\telse if (this.torpDamCount > 0) {\n\t\t\tconst ratio = this.torpDamCount / this.damageCountMax;\n\t\t\tthis.torpDamCount++;\n\t\t\tthis.ssd.drawDamageLabel(ctx, \"Repairing Torpedos\", 100, ratio);\n\n\t\t\tif (this.torpDamCount % 40 > 10) {\n\t\t\t\tthis.ssd.drawTorpIcon(ctx, this.images.torpIcon, this.torpImgOnSSD);\n\t\t\t}\n\t\t}\n\t};\n\n\n\t// draws a fire on the ship after system damage\n\tdrawDamageFire(ctx, fire, loc){\n\t\tconst offsetOfFire = fire.getWidth()/2;\n\n\t\tconst xcoord = this.center()[0] +\n\t\t\tMath.cos(this.rotationOffset + loc.angle) * loc.distance - offsetOfFire;\n\n\t\tconst ycoord = this.center()[1] +\n\t\t\tMath.sin(this.rotationOffset + loc.angle) * loc.distance - offsetOfFire;\n\n\t\tfire.draw(ctx, { x: xcoord, y: ycoord }, this.shiftDir);\n\t};\n\n\n\t// draw the phaser fire. The line extends toward the target over phaserDrawMax frames,\n\t// then stays there for a few frames\n\tdrawPhaser(ctx, angle, damage) {\n\n\t\tconst phaserDrawMax = 20;\n\n\t\t// moves the starting point for the phaser(on the saucer for the enterprise, on the wing for bop)\n\t\tconst xStartingPoint = this.center()[0] + \n\t\t\tMath.cos(this.rotationOffset + angle) * this.phaserOffsetDistance;\n\t\t\t\n\t\tconst yStartingPoint = this.center()[1] + \n\t\t\tMath.sin(this.rotationOffset + angle) * this.phaserOffsetDistance;\n\n\t\tlet xDelta = this.ptarget.center()[0] - xStartingPoint;\n\t\tlet yDelta = this.ptarget.center()[1] - yStartingPoint;\n\n\t\t// beam should stop if it hits a shield\n\t\tlet distance = Utils.distance(this.center(), this.ptarget.center());\n\t\tif (this.targetShieldHP > 0) {\n\t\t\tif (distance > 35 ) {\n\t\t\t\tconst distanceRatio = (distance - 35) / distance;\n\t\t\t\tdistance -= 35;\n\t\t\t\txDelta = xDelta * distanceRatio;\n\t\t\t\tyDelta = yDelta * distanceRatio;\n\t\t\t}\n\t\t}\n\n\t\tlet increasingRatio = this.phaserCounter / phaserDrawMax;\n\t\tif (increasingRatio > 1) increasingRatio = 1;\n\n\t\tconst xProgress = increasingRatio * xDelta + xStartingPoint;\n\t\tconst yProgress = increasingRatio * yDelta + yStartingPoint;\n\n\t\tctx.strokeStyle = this.phaserColor;\n\t\tctx.beginPath();\n\t\tctx.lineWidth = 3;\n\t\tif (this.beamDamCount > 0) ctx.lineWidth = 1;\n\t\tctx.setLineDash(this.beamPattern);  // bop beam is a dotted line\n\t\t\n\t\t// this callback draws the beam which can be straight, wavy, or circles depending on the callback\n\t\tthis.callbacks.beamDrawCB(ctx, \n\t\t\t{ x: xStartingPoint, y: yStartingPoint }, \n\t\t\t{ x: xProgress, y: yProgress });\n\n\t\tctx.stroke();\n\t\tctx.setLineDash([]);\t// in case line was dotted, this sets it back to solid\n\n\n\t\tif (angle === this.phaserOffsetAngle) this.phaserCounter++;\n\n\t\tif (this.phaserCounter === phaserDrawMax && damage > 0) {\n\t\t\tthis.targetShieldHP = this.ptarget.receivePhaserHit(this, damage,\n\t\t\t\t\t[xProgress-this.ptarget.center()[0],yProgress-this.ptarget.center()[1]]);\n\t\t}\n\n\t\tif (this.phaserCounter > phaserDrawMax && damage > 0) {\n\t\t\tif (this.targetShieldHP > 0) {\n\t\t\t\tthis.ptarget.drawShieldOnHit(ctx, this.ptarget.shieldHit);\n\t\t\t}\n\n\t\t\tlet sizeFactor = 1;\n\t\t\tif (this.targetShieldHP === 0) sizeFactor = 1.5;\n\n\t\t\t//draws sparks effect when beam hits\n\t\t\tif (this.phaserCounter%2 === 0) {\n\t\t\t\tctx.drawImage(this.images.sparksImg, 1, 25, 92, 108, \n\t\t\t\t\txProgress - 5 * sizeFactor, yProgress - 5 * sizeFactor, \n\t\t\t\t\t10 * sizeFactor, 10 * sizeFactor);\n\t\t\t}\n\t\t\telse \n\t\t\t\tctx.drawImage(this.images.sparksImg, 120, 2, 165, 148, \n\t\t\t\t\txProgress - 7 * sizeFactor, yProgress - 7 * sizeFactor, \n\t\t\t\t\t14 * sizeFactor, 14 * sizeFactor);\n\t\t}\n\n\t\t// zeros the counter and ends the beam effect\n\t\tif (this.phaserCounter > (phaserDrawMax+15)) {\n\t\t\tthis.phaserCounter = 0;\n\t\t\tthis.targetShieldHP = 1;\n\t\t}\n\t};\n\n\n\tdrawTorpExplosion(ctx) {\t\n\t\tlet x = this.center()[0];\n\t\tlet y = this.center()[1] - 5;\n\t\tlet colorOfToken = \"red\";\n\n\t\t// if it hits a shield, it explodes there\n\t\tif (this.ssd.getShields()[this.shieldHit].getHitpoints() > 0) {\n\t\t\tconst xDelta = this.attacker.center()[0] - this.center()[0];\n\t\t\tconst yDelta = this.attacker.center()[1] - this.center()[1];\n\t\t\tconst distance = Utils.distance(this.center(), this.attacker.center());\n\t\t\tconst percentage = 35 / distance;\n\t\t\tx = this.center()[0] - 5 + xDelta * percentage;\n\t\t\ty = this.center()[1] - 8 + yDelta * percentage;\n\n\t\t\tcolorOfToken = \"#ADD8E6\";\n\t\t\tthis.drawShieldOnHit(ctx, this.shieldHit);\n\t\t}\n\t\t\n\t\tif (this.torpExplosionCounter === 1) {\n\t\t\tlet hitCoords = [x - this.center()[0], y - this.center()[1]] ;\n\n\t\t\tif (colorOfToken === \"red\") {\n\t\t\t\thitCoords[0] = hitCoords[0] *4;\n\t\t\t\thitCoords[1] = hitCoords[1] * 4;\n\t\t\t};\n\t\t\tlet damage = this.attacker.getTorpedoDamage();\n\t\t\tlet last = this.damageTokens.length - 1;\n\t\t\tif (last > -1 && this.damageTokens[last].key === this.torpHitKey) \n\t\t\t\tthis.damageTokens[last].damage += damage;\n\t\t\telse this.damageTokens.push(\n\t\t\t\t{ hitCoords, damage, colorOfToken, time:0, key:this.torpHitKey });\n\t\t}\n\n\t\tctx.drawImage(this.images.explosionImg, 606, 295, 100, 100, x, y, 10, 10);\n\t};\n\n\n\tdrawShieldOnHit(ctx, shieldNum){\n\t\tconst startAndEnd = [\n\t\t\t[1.75,  .25],\n\t\t\t[ .25,  .75],\n\t\t\t[ .75, 1.25],\n\t\t\t[1.25, 1.75]\n\t\t];\n\n\t\tconst gradient = ctx.createRadialGradient(\n\t\t\tthis.center()[0], this.center()[1], 21, \n\t\t\tthis.center()[0], this.center()[1], 37);\n\n\t\tgradient.addColorStop(1, \"#00FFFF\");\n\n\t\tgradient.addColorStop(0, \"transparent\");\n\t\t\n\t\tctx.beginPath();\n\t\tctx.arc(\n\t\t\tthis.center()[0],\n\t\t\tthis.center()[1],\n\t\t\t35,\n\t\t\tstartAndEnd[shieldNum][0] * Math.PI + this.rotationOffset,\n\t\t\tstartAndEnd[shieldNum][1] * Math.PI + this.rotationOffset\n\t\t);\n\n\t\tctx.fillStyle = gradient;\n\t\tctx.fill();\n\t};\n\n\n\tdrawShipExplosion(ctx) {\n\t\treturn this.explosion.draw(ctx, this.center());\n\t};\n\n\t\n\tdrawDamageTokens(ctx) {\n\t\tconst enlargeStop = 20;\n\t\tlet factor = 1;\n\n\t\tthis.damageTokens.forEach((token, i) => {\n\t\t\tctx.fillStyle = token.colorOfToken;\n\n\t\t\tif (token.time < enlargeStop) factor = token.time/enlargeStop;\n\t\t\telse factor = 1;\n\t\t\t\n\t\t\tctx.font = 20*factor + \"px FINALOLD\"; \n\t\t\tctx.fillText(\"-\" + token.damage, \n\t\t\t\t(this.center()[0] + token.hitCoords[0] * 1.1) -10, \n\t\t\t\tthis.center()[1] + token.hitCoords[1] * 1.1);\n\n\t\t\ttoken.time++;\n\t\t\tif (token.time === 40) this.damageTokens.splice(i, 1);\n\t\t})\n\t};\n\n\n\tconsultAI(onscreen) {\n\t\tthis.AI.consultAI(onscreen);\n\t};\n\n\n\tpower(impulse) {\n\t\tif (impulse > 0 && this.speed < 2) {\n\t\t\t// next line takes engine damage into account\n\t\t\tif (this.engineDamCount === 0 || this.speed < .5) this.speed += impulse;\n\t\t}\n\t\telse if (impulse < 0 && this.speed > -1) {\n\t\t\t// next line takes engine damage into account\n\t\t\tif (this.engineDamCount === 0 || this.speed > -.5) this.speed += impulse;\n\t\t}\n\t};\n\n\n\tfirePhasers() {\n\t\tif (this.phaserRecharge === this.phaserRechargeMax) {\n\t\t\tthis.phaserCounter = 1;\n\t\t\tthis.ptarget = this.target;\n\t\t\tthis.phaserRecharge = 0;\n\t\t\tthis.beamSound.play();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\n\tfireTorpedos() {\n\t\tif (this.torpedoReload >= this.torpedoReloadMax && this.onscreen()) {\n\t\t\tthis.torpedoReload = 0;\n\t\t\tthis.torpSound.play();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\n\treceivePhaserHit(attacker, damage, hitCoords) {\n\t\tlet colorOfToken;\n\t\tconst hp = this.takeDamage(attacker, damage);\n\n\t\tif (hp > 0) colorOfToken = \"#ADD8E6\";\n\t\telse colorOfToken = \"red\";\n\n\t\tthis.damageTokens.push({hitCoords, damage, colorOfToken, time:0});\n\t\t\n\t\treturn hp;\n\t};\n\n\n\treceiveTorpHit(torpedo) {\n\t\tlet damage = torpedo.getLauncher().getTorpedoDamage();\n\n\t\tthis.takeDamage(torpedo.getLauncher(),damage);\n\t\t\n\t\tthis.torpExplosionCounter = 1;\n\t\tthis.torpHitKey = torpedo.getKey();\n\t};\n\n\n\ttakeDamage(attacker, damage){\n\t\tthis.attacker = attacker;\n\n\t\tthis.whichShieldWasHit(attacker);\n\t\tconst hp = this.ssd.getShields()[this.shieldHit].getHitpoints();\n\t\tif (hp > 0) {\n\t\t\tthis.ssd.getShields()[this.shieldHit].hit(damage);\n\t\t}\n\t\telse {\n\t\t\tthis.hullIntegrity -= damage;\n\t\t\tif (this.hullIntegrity < 0) this.hullIntegrity = 0;\n\t\t\telse this.determineSystemDamage();\n\n\t\t\tthis.ssd.updateImg(this.hullIntegrity / this.hullIntegrityMax);\n\t\t}\n\n\t\treturn hp;\n\t};\n\n\t\n\tdetermineSystemDamage() {\n\t\tconst rand = Math.random();\n\n\t\tif (this.engineDamCount === 0 && rand < .2) {\n\t\t\tthis.engineDamCount = 1;\n\n\t\t\tif (this.speed > .5) this.speed = .5;\n\t\t\telse if (this.speed < -.5) this.speed = -.5;\t\n\n\t\t\tthis.engineFire = new Fire(this.images.fireImg);\n\t\t}\n\t\telse if (this.beamDamCount === 0 && rand >= .2 && rand < .4) {\n\t\t\tthis.beamDamCount = 1;\n\t\t\tthis.phaserDamage = this.phaserDamage / 2;\n\t\t\tthis.beamFire = new Fire(this.images.fireImg);\n\t\t}\n\t\telse if (this.torpDamCount === 0 && rand >= .4 && rand < .6) {\n\t\t\tthis.torpDamCount = 1;\n\t\t\tthis.torpedoReloadMax = this.torpedoReloadMax * 2;\n\t\t\tthis.torpFire = new Fire(this.images.fireImg);\n\t\t}\n\t};\n\n\t\n\twhichShieldWasHit(attacker) {\n\t\tconst angle = Utils.angleToOtherShip(this, attacker);\n\n\t\tif (angle <= .25 * Math.PI || angle >= 1.75 * Math.PI) this.shieldHit = 0;\n\t\telse if (angle > .25 * Math.PI && angle < .75 * Math.PI) this.shieldHit = 1;\n\t\telse if (angle >= .75 * Math.PI && angle <= 1.25 * Math.PI) this.shieldHit = 2;\n\t\telse this.shieldHit = 3;\n\t};\n\n\n\tchangeDirection(dir) { \n\t\tconst increment = Math.PI / 72;\n\n\t\tthis.rotationOffset += dir*increment;\n\n\t\tif (this.rotationOffset > 6.28) this.rotationOffset -= Math.PI *2;\n\t\telse if (this.rotationOffset < -.000000001) this.rotationOffset += Math.PI * 2;\n\n\t\tthis.direction = this.calcDirection(this.rotationOffset);\n\t};\n\n\n\tcalcDirection(rotationOffset) {\n\t\treturn {x:Math.cos(rotationOffset) * 7, y:Math.sin(rotationOffset) * -7};\n\t};\n};\n\nmodule.exports = Ship\n\n//# sourceURL=webpack:///./src/ships/ship.js?");

/***/ }),

/***/ "./src/ships/soyuz.js":
/*!****************************!*\
  !*** ./src/ships/soyuz.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Frigate = __webpack_require__(/*! ./frigate */ \"./src/ships/frigate.js\");\nconst SSD = __webpack_require__(/*! ../ssd */ \"./src/ssd.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass Soyuz extends Frigate {\n\tconstructor(options) {\n\t\tsuper(options);\n\n\t\tthis.enemy = false;\n\n\t\tthis.shipImg = { \n\t\t\timage: this.images.soyuzImg, x: 0, y: 0, width: 362, height: 237 };\n\t\t\t\n\t\tthis.width = 35;\n\t\tthis.height = 28;\n\t\tthis.beamPattern = [];\n\n\t\tthis.beamSound = options.sounds.disrupt2Sound;\n\t\tthis.torpSound = options.sounds.torpSound;\n\n\t\tthis.engineDamageDim = {left_x: 7, right_x: 60, y: 78, width: 3, height: 35};\n\t\tthis.beamDamageDim = { left_x: -5, right_x: 72, y: 44, width: 3, height: 20};\n\t\tthis.torpImgOnSSD = { x: 30, y: 55 };\n\n\t\tthis.engineFireLoc = { angle: 1.18 * Math.PI, distance: 18 };\n\t\tthis.beamFireLoc = { angle: .5 * Math.PI, distance: 14 };\n\t\tthis.torpFireLoc = { angle: 0, distance: 0 };\n\n\t\tthis.callbacks = {\n\t\t\tbeamDrawCB: Utils.drawCircleBeam,\n\t\t\tengineDamCB: Utils.drawRect,\n\t\t\tbeamDamCB: Utils.drawRect\n\t\t};\n\n\t\tthis.phaserRechargeMax = 170;\n\t\tthis.torpedoReloadMax = 200;\n\n\t\tthis.phaserOffsetDistance = 13;\n\t\tthis.phaserOffsetAngle = 1.5 * Math.PI;\n\t\tthis.phaserColor = \"red\";\n\n\t\tthis.phaserDamage = 10;\n\t\tthis.hullIntegrityMax = 100;\n\t\tthis.hullIntegrity = this.hullIntegrityMax;\n\n\t\t// ssd is the ship systems display in the corner of the screen\n\t\tthis.ssd = new SSD({\n\t\t\tssdPos: options.ssdPos,\n\t\t\timg_size: [80, 100],\n\t\t\timg_pos_offset: [-5, 10],\n\t\t\timg: this.images.soyuzSsdImg,\n\t\t\tbeamWeaponName: 'Phaser',\n\t\t\timgCoords: [0, 0, 202, 298],\n\t\t\tshieldStrength: 40,\n\t\t});\n\t};\n}\n\nmodule.exports = Soyuz;\n\n//# sourceURL=webpack:///./src/ships/soyuz.js?");

/***/ }),

/***/ "./src/solarSystem/comet.js":
/*!**********************************!*\
  !*** ./src/solarSystem/comet.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const OrbitingObject = __webpack_require__(/*! ./orbiting_object */ \"./src/solarSystem/orbiting_object.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass Comet extends OrbitingObject {\n\tconstructor(options) {\n\t\tsuper(options);\n\t\tthis.tailLength = 100;\n\t};\n\n\n\tdraw(ctx, tilt) {\n\t\ttilt -= .12;\n\n\t\tconst orbitPos = this.suns[0].getPosition();\n\t\tconst orbitRad = this.suns[0].radius;\n\n\t\t// hopefully comet isn't drawn when it's behind sun\n\t\tif (this.pos.x > orbitPos.x + orbitRad/4 || \n\t\t\tthis.pos.x < orbitPos.x - orbitRad/4 ||\n\t\t\tthis.pos.y > orbitPos.y) {\n\t\t\t\t\t\n\t\t\tsuper.draw(ctx, tilt);\n\t\t\tthis.drawTail(ctx,tilt);\n\t\t}\n\t};\n\n\n\t// the tail is a gradient in a triangle that extends behind the comet away from sun\n\tdrawTail(ctx,tilt) {\n\t\tlet y = this.yAfterTilt;\n\t\tlet x = this.pos.x;\n\n\t\tconst endOfTail = this.findEndOfTail(tilt);\n\n\t\tconst angle = Utils.findAngle([x,y], \n\t\t\t[this.suns[0].getPosition().x, this.suns[0].getPosition().y]);\n\n\t\tconst leftEdgeOfComet = this.getEdgeOfComet(x,y,angle + Math.PI / 2);\n\t\tconst rightEdgeOfComet = this.getEdgeOfComet(x,y,angle - Math.PI / 2);\n\n\t\tctx.fillStyle = this.createGradient(ctx, {x,y}, endOfTail);\n\n\t\tctx.moveTo(leftEdgeOfComet.x, leftEdgeOfComet.y);\n\t\tctx.lineTo(rightEdgeOfComet.x, rightEdgeOfComet.y);\n\t\tctx.lineTo(endOfTail.x, endOfTail.y);\n\t\tctx.lineTo(leftEdgeOfComet.x, leftEdgeOfComet.y);\n\t\tctx.fill();\n\t};\n\n\n\tcreateGradient(ctx, start, end) {\n\t\tconst gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n\t\tgradient.addColorStop(0, this.color);\n\t\tgradient.addColorStop(1, \"transparent\");\n\t\treturn gradient;\n\t};\n\n\n\tgetEdgeOfComet(x, y, angle) {\n\t\tconst xOffset = Math.cos(angle) * this.radius * this.radiusMult;\n\t\tconst yOffset = Math.sin(angle) * this.radius * this.radiusMult;\n\n\t\treturn {x: x + xOffset, y: y + yOffset};\n\t};\n\n\n\tfindEndOfTail(tilt) {\n\t\tconst deltaX = this.pos.x - this.centerOfSS.x;\n\t\tconst deltaY = this.pos.y - this.centerOfSS.y;\n\n\t\tconst ratio = (this.tailLength + this.distance) / this.distance;\n\n\t\tlet tailX = deltaX * ratio + this.centerOfSS.x;\n\t\tlet tailY = deltaY * ratio + this.centerOfSS.y;\n\n\n\t\tconst distanceFromSunY = tailY - this.centerOfSS.y;\n\t\tconst tailYAfterTilt = distanceFromSunY * tilt + this.centerOfSS.y;\n\n\t\treturn {x:tailX, y:tailYAfterTilt};\n\t};\n\n}\n\nmodule.exports = Comet;\n\n//# sourceURL=webpack:///./src/solarSystem/comet.js?");

/***/ }),

/***/ "./src/solarSystem/moon.js":
/*!*********************************!*\
  !*** ./src/solarSystem/moon.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const OrbitingObject = __webpack_require__(/*! ./orbiting_object */ \"./src/solarSystem/orbiting_object.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass Moon extends OrbitingObject {\n\tconstructor(options) {\n\t\tsuper(options);\n\t};\n\n\taddSun(sun) { this.suns.push(sun); };\n\n\n\tshift(shiftX, shiftY) {\n\t\tthis.pos.x +=\tshiftX;\n\t\tthis.pos.y += shiftY;\n\t}\n\n\tdraw(ctx, tilt, orbitCenterY, mult) {\n\t\tconst positionOffsetY = (this.pos.y - this.suns[0].getPosition().y) * tilt *mult;\n\n\t\tconst positionOffsetX = (this.pos.x - this.suns[0].getPosition().x);\n\t\tconst newX = this.suns[0].getPosition().x + positionOffsetX*mult;\n\n\t\tUtils.drawFilledCircle(ctx, newX, orbitCenterY + positionOffsetY, this.radius*mult, this.color);\n\t\t\n\t}\n}\n\nmodule.exports = Moon;\n\n//# sourceURL=webpack:///./src/solarSystem/moon.js?");

/***/ }),

/***/ "./src/solarSystem/orbiting_object.js":
/*!********************************************!*\
  !*** ./src/solarSystem/orbiting_object.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass OrbitingObject {\n\tconstructor(options) {\n\t\tthis.pos = options.pos;\n\t\tthis.radius = options.radius;\n\t\tthis.mass = options.mass;\n\t\tthis.color = options.color;\n\t\tthis.dir = options.dir;\n\t\tthis.speed = options.speed;\n\n\t\tif (options.suns) this.suns = options.suns;\n\t\telse this.suns = [];\n\n\t\tthis.centerOfSS = options.centerOfSS;\t\t\n\t\tthis.path = options.path;\n\t\tthis.moonData = options.moonData;\n\t\tthis.moons = [];\n\t\tthis.centerOfSS = options.center;\n\n\t\tthis.gradientColors = options.gradientColors;\n\n\t\tthis.rings = options.rings;\n\t\tthis.ringsColor = options.ringsColor;\n\t\tthis.yAfterTilt;\n\n\t\tthis.farAwayMultiplier = .75;\n\t\tthis.closeMultiplier = 1.25;\n\t};\n\n\tgetPosition() { return this.pos; };\n\tgetMass() { return this.mass; };\n\tgetRadius() { return this.radius; };\n\n\taddMoon(moon) { this.moons.push(moon); };\n\tgetMoons() { return this.moons; };\n\tgetMoonData() { return this.moonData; };\n\tsetColor(color) { this.color = color; };\n\taddSun(sun) { this.suns.push(sun); };\n\n\tmove() {\n\t\tthis.suns.forEach(sun => {\n\n\t\t\tconst constant = 2.5;\n\t\t\tthis.distance = Utils.distance([this.pos.x, this.pos.y],\n\t\t\t\t[sun.getPosition().x, sun.getPosition().y]);\n\n\t\t\tconst deltaX = sun.getPosition().x - this.pos.x;\n\t\t\tconst deltaY = sun.getPosition().y - this.pos.y;\n\n\t\t\tconst gravity = constant * this.mass * sun.getMass() / \n\t\t\t\t(this.distance * this.distance);\n\n\t\t\t// mass of planet acutally cancels out so is actually unnecessary\n\t\t\tthis.dir.x += deltaX / this.distance * gravity / this.mass;\n\t\t\tthis.dir.y += deltaY / this.distance * gravity / this.mass;\n\t\t});\n\n\t\tconst movementX = this.dir.x * this.speed;\n\t\tconst movementY = this.dir.y * this.speed;\n\n\t\tthis.pos.x += movementX;\n\t\tthis.pos.y += movementY;\n\n\t\tthis.moons.forEach(moon =>{\n\t\t\tmoon.shift(movementX, movementY);\n\t\t\tmoon.move();\n\t\t});\n\n\t};\n\n\n\tdraw(ctx, tilt) {\n\n\n\t\tlet distanceFromSunY = this.pos.y - this.centerOfSS.y;\n\n\t\t// objects above sun are closer together on tilt\n\t\tif (distanceFromSunY < 0) distanceFromSunY *= this.farAwayMultiplier;\n\t\tif (distanceFromSunY > 0) distanceFromSunY *= this.closeMultiplier;\n\n\t\tthis.yAfterTilt =  distanceFromSunY*tilt +this.centerOfSS.y ;\n\n\t\tthis.radiusMult = 1 +  distanceFromSunY/300;\n\n\t\tthis.radiusMult = this.radiusMult - this.radiusMult*tilt + 1;\n\n\n\t\tif (this.gradientColors) this.color = this.generateRGradient(ctx, this.gradientColors);\n\n\t\t// draw moon if it's in back of planet\n\t\tthis.moons.forEach(moon => {\n\t\t\tif (moon.getPosition().y < this.pos.y) \n\t\t\t\tmoon.draw(ctx, tilt, this.yAfterTilt, this.radiusMult);\n\t\t});\n\n\t\t// back of rings drawn\n\t\tif (this.rings) \n\t\t\tthis.rings.forEach((ring)=> this.drawRings(ctx, ring, this.yAfterTilt, Math.PI));\n\n\t\t// planet drawn\n\t\tUtils.drawFilledCircle(ctx, \n\t\t\tthis.pos.x, this.yAfterTilt, \n\t\t\tthis.radius * this.radiusMult, this.color);\n\n\t\t// front of rings drawn\n\t\tif (this.rings)\n\t\t\tthis.rings.forEach((ring) => this.drawRings(ctx, ring, this.yAfterTilt, 0));\n\n\t\t// draw moon if it's in front of planet\n\t\tthis.moons.forEach(moon => {\n\t\t\tif (moon.getPosition().y >= this.pos.y)\n\t\t\t\tmoon.draw(ctx, tilt, this.yAfterTilt, this.radiusMult);\n\t\t});\n\t};\n\n\n\tgenerateRGradient(ctx, colors) {\n\t\tconst distance = Utils.distance([this.pos.x, this.yAfterTilt], \n\t\t\t[this.centerOfSS.x,this.centerOfSS.y]);\n\n\t\tlet radius1 = distance - this.radius * .9;\n\t\tif (radius1 < 0) radius1 = 0;\n\n\t\tlet radius2 = distance + this.radius * 2;\n\t\tif (radius2 < 0) radius2 = 0;\n\n\t\tconst gradient = ctx.createRadialGradient(\n\t\t\tthis.centerOfSS.x, this.centerOfSS.y-distance/5,radius1,\n\t\t\tthis.centerOfSS.x, this.centerOfSS.y-distance/5, radius2);\n\n\t\tgradient.addColorStop(0, colors.a);\n\t\tgradient.addColorStop(1, colors.b);\n\n\t\treturn gradient;\n\n\t};\n\n\n\tdrawRings(ctx, ring, y, start) {\n\t\tctx.beginPath();\n\t\tctx.lineWidth = ring.thickness * this.radiusMult;\n\t\tctx.strokeStyle = this.ringsColor;\n\t\tctx.ellipse(this.pos.x, y, \n\t\t\tring.radius*this.radiusMult, \n\t\t\tring.radius/3*this.radiusMult,\n\t\t\tring.angle, start-.01, start+Math.PI+.01);\n\t\tctx.stroke();\n\t};\n\n\n\n\tdrawPath(ctx, tilt) {\n\t\tif (this.path) {\n\t\t\tctx.beginPath();\n\t\t\tctx.lineWidth = .5;\n\t\t\tctx.strokeStyle = \"white\";\n\t\t\tctx.ellipse(this.centerOfSS.x, this.centerOfSS.y,\n\t\t\t\tthis.distance, this.distance * tilt* this.closeMultiplier, 0, 0, Math.PI);\n\t\t\tctx.ellipse(this.centerOfSS.x, this.centerOfSS.y,\n\t\t\t\tthis.distance, this.distance * tilt * this.farAwayMultiplier, 0, Math.PI,0);\t\t\t\n\t\t\tctx.stroke();\n\n\t\t}\n\t};\n}\n\nmodule.exports = OrbitingObject;\n\n//# sourceURL=webpack:///./src/solarSystem/orbiting_object.js?");

/***/ }),

/***/ "./src/solarSystem/solar_system.js":
/*!*****************************************!*\
  !*** ./src/solarSystem/solar_system.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Star = __webpack_require__(/*! ../non-ship_space_objects/star */ \"./src/non-ship_space_objects/star.js\");\nconst Moon = __webpack_require__(/*! ./moon */ \"./src/solarSystem/moon.js\");\nconst Utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nclass SolarSystem {\n\n\tconstructor(starCount, bottomOfStarField) {\n\t\tthis.suns = [];\n\t\tthis.planets = [];\n\n\t\tthis.tilt = 1;\n\t\tthis.center = { x: Utils.getCanvasDim().x / 2, y: Utils.getCanvasDim().y / 2 };\n\n\t\tthis.stars = new Array(starCount);\n\t\tfor (let i = 0; i < this.stars.length; i++) {\n\t\t\tconst starData = Utils.createStarData(Utils.getCanvasDim().x, bottomOfStarField);\n\t\t\tthis.stars[i] = new Star(starData);\n\t\t};\t\n\t};\n\n\tgetTilt() { return this.tilt; };\n\tsetTilt(tilt) { this.tilt = tilt; };\n\tgetSuns() { return this.suns; };\n\tgetCenter() { return this.center; }\n\tsetCenter(center) { this.center = center; }\n\n\n\taddSun(sun) {\n\t\tthis.suns.push(sun);\n\t};\n\n\n\taddPlanet(planet) {\n\t\tlet moon;\n\t\t\n\t\t// construct moons from data in the planet object\n\t\tif (planet.getMoonData()) {\n\t\t\tplanet.getMoonData().forEach(data => {\n\t\t\t\tmoon = new Moon(data);\n\t\t\t\tmoon.addSun(planet);\n\t\t\t\tplanet.addMoon(moon);\n\t\t\t})\n\t\t}\n\t\tthis.planets.push(planet);\n\t};\n\n\n\tstep() {\n\t\tthis.moveObjects();\n\t};\n\n\n\tdraw(ctx) {\n\t\tthis.stars.forEach((star) => star.draw(ctx));\n\t\tthis.suns.forEach((sun) => sun.draw(ctx, this.tilt));\n\t\tthis.planets.forEach((planet) => planet.drawPath(ctx, this.tilt));\n\t\tthis.planets.forEach((planet) => planet.draw(ctx, this.tilt));\n\t};\n\n\tmoveObjects(){\n\t\tthis.suns.forEach((sun) => sun.move());\n\n\t\tthis.planets.forEach((planet) => planet.move());\n\t};\n}\n\nmodule.exports = SolarSystem;\n\n\n//# sourceURL=webpack:///./src/solarSystem/solar_system.js?");

/***/ }),

/***/ "./src/solarSystem/ss_data1.js":
/*!*************************************!*\
  !*** ./src/solarSystem/ss_data1.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const OrbitingObject = __webpack_require__(/*! ./orbiting_object */ \"./src/solarSystem/orbiting_object.js\");\nconst Sun = __webpack_require__(/*! ./sun */ \"./src/solarSystem/sun.js\");\nconst Comet = __webpack_require__(/*! ./comet */ \"./src/solarSystem/comet.js\");\n\nconst SSData1 = {\n\t\n\n\taddDataToSS(ss, center) {\n\t\tss.setTilt(.294);\n\t\t// ss.setTilt(0)\n\t\t\n\t\tif (center) ss.setCenter(center);\n\t\telse center = ss.getCenter();\n\t\tlet x;\n\t\tlet y;\n\n\t\t// const o = new SolarObject( {\n\t\t// \tpos: center,\n\t\t// \tradius: 60,\n\t\t// \tmass: 300,\n\t\t// \tcolor: \"yellow\"\n\t\t// });\n\n\t\tss.addSun(new Sun( { \n\t\t\t\tcenter,\n\t\t\t\tpos: center,\n\t\t\t\tradius: 90,\n\t\t\t\tgradientColor: \"yellow\",\n\t\t\t\tmass: 300,\n\t\t\t\tspeed: 0,\n\t\t\t\tsuns: [],\n\t\t\t\tdir: {x:0, y:0}\n\t\t\t})\n\t\t);\n\n\n\t\tx = center.x - 150\n\t\ty = center.y\n\n\t\tconst vensMoon = {\n\t\t\tcenter,\n\t\t\tpos: { x: x - 15, y:y },\n\t\t\tradius: 1,\n\t\t\tcolor: \"pink\",\n\t\t\tmass: .3,\n\t\t\tspeed: 1,\n\t\t\tdir: { x: 0, y: -1 },\n\t\t\tsuns: []\n\t\t};\n\n\t\tss.addPlanet(new OrbitingObject( {\n\t\t\tcenter,\n\t\t\tpos: { x, y },\n\t\t\tradius: 6,\n\t\t\tgradientColors: { a: \"lightgreen\", b: \"darkgreen\" },\n\t\t\tmass: 8,\n\t\t\tsuns: ss.getSuns(),\n\t\t\tspeed: 4.98,\n\t\t\tdir: { x: 0, y: 1 },\n\t\t\tpath: true,\n\t\t\tmoonData: [vensMoon]\n\t\t}));\n\n\n\t\tss.addPlanet(new OrbitingObject({\n\t\t\tcenter,\n\t\t\tpos: { x: center.x + 250, y: center.y },\n\t\t\tradius: 9,\n\t\t\tgradientColors: { a: \"lightblue\", b: \"blue\" },\n\t\t\tmass: 10,\n\t\t\tsuns: ss.getSuns(),\n\t\t\tspeed: 3,\n\t\t\tdir: { x: 0, y: -1 },\n\t\t\tpath: true,\n\t\t\tringsColor: \"darkblue\",\n\t\t\t// ringsGradient: { a: \"blue\", b: \"darkblue\" },\n\t\t\trings: [{radius: 18, angle: Math.PI / 6, thickness: 2 },\n\t\t\t\t{radius: 15, angle: Math.PI / 6, thickness: 2 },\n\t\t\t\t{radius: 12, angle: Math.PI / 6, thickness: 2 }]\n\t\t}));\n\n\n\t\t// ss.addPlanet(new OrbitingObject({\n\t\t// \tcenter,\n\t\t// \tpos: { x: center.x -300, y: center.y },\n\t\t// \tradius: 3,\n\t\t// \tgradientColors: {a: \"#cc66ff\", b: \"#9900cc\" },\n\t\t// \tmass: 6,\n\t\t// \tsuns: ss.getSuns(),\n\t\t// \tspeed: 2.5,\n\t\t// \tdir: { x: 0, y: 1 },\n\t\t// \tpath: true,\n\t\t// }));\n\n\n\t\tx = center.x + 400;\n\t\ty = center.y;\n\n\t\tconst jupsMoon = {\n\t\t\tcenter,\n\t\t\tpos: { x: x - 50, y },\n\t\t\tradius: 2,\n\t\t\tcolor: \"brown\",\n\t\t\tmass: 1.5,\n\t\t\tspeed: 2,\n\t\t\tdir: { x: 0, y: -1 },\n\t\t\tcenter,\n\t\t\tsuns: []\n\t\t};\n\n\t\tss.addPlanet(new OrbitingObject({\n\t\t\tcenter,\n\t\t\tpos: { x: x, y: y },\n\t\t\tradius: 12,\n\t\t\tgradientColors: { a: \"rgb(255, 153, 51)\", b: \"darkred\" },\n\t\t\tmass: 40,\n\t\t\tsuns: ss.getSuns(),\n\t\t\tspeed: 1.90,\n\t\t\tdir: { x: 0, y: -1 },\n\t\t\tcenter,\n\t\t\tpath: true,\n\t\t\tmoonData: [jupsMoon]\n\t\t}));\n\n\n\n\t\tss.addPlanet(new Comet({\n\t\t\tcenter,\n\t\t\tpos: { x: center.x + 150, y: center.y + 250 },\n\t\t\tradius: 1.5,\n\t\t\tcolor: \"rgb(255, 255, 204)\",\n\t\t\tmass: 1,\n\t\t\tsuns: ss.getSuns(),\n\t\t\tspeed: 1.8,\n\t\t\tdir: { x: 0, y: -1 }\n\t\t}));\n\t}\n};\n\nmodule.exports = SSData1;\n\n\n//# sourceURL=webpack:///./src/solarSystem/ss_data1.js?");

/***/ }),

/***/ "./src/solarSystem/sun.js":
/*!********************************!*\
  !*** ./src/solarSystem/sun.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const OrbitingObject = __webpack_require__(/*! ./orbiting_object */ \"./src/solarSystem/orbiting_object.js\");\n\nclass Sun extends OrbitingObject{\n\tconstructor(options) {\n\t\tsuper(options);\n\t\tthis.gradientColor = options.gradientColor;\n\t\t// this.lastPos;\n\t};\n\n\t// getLastPos() { return this.lastPositon; };\n\n\tdraw(ctx, tilt) {\n\n\t\tconst gradient = ctx.createRadialGradient(\n\t\t\tthis.pos.x, this.pos.y, this.radius / 4,\n\t\t\tthis.pos.x, this.pos.y, this.radius);\n\t\t// debugger\n\t\tgradient.addColorStop(0, this.gradientColor);\n\t\tgradient.addColorStop(1, \"transparent\");\n\n\t\tthis.color = gradient;\n\t\tsuper.draw(ctx, tilt);\n\t};\n\n\t// move(i) {\n\t\t// if (i != 0) super.move(true);\n\t\t// else {\n\t\t// \tthis.lastPos = this.pos;\n\t\t\t// super.move();\n\t\t// }\n\t// }\n\n}\n\nmodule.exports = Sun;\n\n//# sourceURL=webpack:///./src/solarSystem/sun.js?");

/***/ }),

/***/ "./src/ssd.js":
/*!********************!*\
  !*** ./src/ssd.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Shield = __webpack_require__(/*! ./shield */ \"./src/shield.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n// SSD is the ship's systems display in the corner of the screen\nclass SSD {\n\tconstructor(options) {\n\t\tthis.ssd_x = options.ssdPos[0];\n\t\tthis.ssd_y = options.ssdPos[1];\n\t\tthis.scale = options.ssdPos[2];\n\t\tthis.labels = options.ssdPos[3];\n\t\tthis.engineDamageDim = options.engineDamageDim;\n\t\t\n\t\tthis.ssd_total_width = 70 * this.scale;\n\t\tthis.ssd_total_height = 120 * this.scale;\n\n\t\tthis.img_pos_offset = options.img_pos_offset;\n\t\tthis.img_size_x = options.img_size[0] * this.scale;\n\t\tthis.img_size_y = options.img_size[1] * this.scale;\n\t\tthis.img_pos_x = this.ssd_x + this.img_pos_offset[0] * this.scale;\n\t\tthis.img_pos_y = this.ssd_y + this.img_pos_offset[1];\n\n\t\tthis.imgCoords = options.imgCoords;\n\t\tthis.beamWeaponName = options.beamWeaponName;\n\t\tthis.shieldStrength = options.shieldStrength;\n\t\tthis.SSDimg = options.img;\n\n\t\tthis.setUpVirtualCanvas();\n\n\t\tthis.shields = [];\n\t\tthis.raiseShields();\n\t};\n\n\n\tgetBeamName() { return this.beamWeaponName; };\n\tgetShields() { return this.shields; };\n\tsetLabels(val) { this.labels = val; };\n\n\n\t// draw original image on virtual canvas and call captureImage to get the data\n\tsetUpVirtualCanvas() {\n\t\tthis.virtualCanvas = document.createElement('canvas');\n\t\tthis.virtualCanvas.width = this.img_size_x;\n\t\tthis.virtualCanvas.height = this.img_size_y;\n\t\tthis.virtualCtx = this.virtualCanvas.getContext('2d');\n\n\t\tthis.virtualCtx.drawImage(this.SSDimg, this.imgCoords[0], this.imgCoords[1], this.imgCoords[2], this.imgCoords[3],\n\t\t\t0, 0, this.img_size_x, this.img_size_y);\n\n\t\tthis.captureImage();\n\t};\n\n\t// this function gets the ssd imageData from the virtual canvas after it's drawn\n\t// it then sets the black pixels to transparent\n\tcaptureImage() {\n\t\tthis.imgData = this.virtualCtx.getImageData(0, 0, this.img_size_x, this.img_size_y);\n\n\t\t// // sets the black pixels to transparent\n\t\tfor (let index = 0; index < this.imgData.data.length; index += 4) {\n\t\t\tif (this.imgData.data[index] === 0) this.imgData.data[index + 3] = 0;\t\t\n\t\t}\n\n\t\tthis.updateImg(1);\n\t};\n\n\n\t// updates the image data, making pixels red with current hull %\n\t// then puts image data on a canvas which is then turned into an image.\n\t// Called once from captureImage() and then called from takeDamage() in ship class\n\tupdateImg(hullPercentage){\n\t\tconst start = Math.floor(this.imgData.data.length * hullPercentage / 4.0) * 4;\n\t\tfor (let index = start; index < this.imgData.data.length; index += 4) {\n\t\t\t// if (this.imgData.data[index] === 153) break;\n\t\t\tif (this.imgData.data[index] !== 0) {\n\t\t\t\tthis.imgData.data[index] = 250;\n\t\t\t\tthis.imgData.data[index + 1] = 0;\n\t\t\t\tthis.imgData.data[index + 2] = 0;\n\t\t\t}\t\t\t\n\t\t}\n\t\tthis.virtualCtx.putImageData(this.imgData, 0, 0);\n\t\tthis.updatedImg = new Image();\n\t\tthis.updatedImg.src = this.virtualCanvas.toDataURL();\n\t};\n\n\n\tdraw(ctx, phaserRechargePercent, torpedoReloadPercent, hullPercentage, target) {\n\n\t\tctx.drawImage(this.updatedImg, this.img_pos_x, this.img_pos_y);\t\t\n\t\t\n\t\tctx.beginPath(); \n\t\t\n\t\tthis.drawShields(ctx);\n\t\tctx.lineWidth = 3;\n\n\t\t// draw phaser recharge bar\n\t\tthis.drawRechargeBar(ctx, this.ssd_x - 60, phaserRechargePercent);\n\n\t\t// draw torpedo reload\n\t\tthis.drawRechargeBar(ctx, this.ssd_x + this.ssd_total_width + 50, torpedoReloadPercent);\n\n\t\tthis.drawHullIntegrity(ctx, hullPercentage);\n\n\t\tif(this.labels) this.drawLabels(ctx);\n\n\t\tif (target) Utils.drawTarget(ctx, this.ssd_x - 30 + 0 * this.scale, \n\t\t\tthis.ssd_y +10 - 20 * this.scale, 15 * this.scale, 2);\n\t};\n\n\n\tdrawShields(ctx) {\n\t\tthis.shields.forEach((shield) => shield.draw(ctx, this.scale))\n\t};\n\n\n\tdrawRechargeBar(ctx, x, percentage) {\n\t\tlet bar_height = this.ssd_total_height - 6;\n\n\t\tctx.beginPath();\n\t\tctx.rect(x, this.ssd_y, 10, this.ssd_total_height);\n\t\tctx.strokeStyle = \"grey\";\n\t\tctx.stroke();\n\n\t\tctx.beginPath();\n\t\tif (percentage === 1) ctx.fillStyle = \"green\";\n\t\telse ctx.fillStyle = \"grey\";\n\t\tctx.fillRect(x+3, this.ssd_y + 3 + bar_height*(1-percentage), 4, bar_height*percentage);\n\t};\n\n\n\tdrawHullIntegrity(ctx, hullPercentage) {\n\t\tctx.font = \"18px Arial\";\n\t\tif (hullPercentage >= .85) ctx.fillStyle = \"#FAFAD2\";\n\t\telse if (hullPercentage >= .35) ctx.fillStyle = \"yellow\";\n\t\telse ctx.fillStyle = \"red\";\n\n\t\tctx.fillText(\"Hull Integrity: \" + Math.floor(hullPercentage*100) + \"%\", \n\t\t\tthis.ssd_x-43-30*(1-this.scale), this.ssd_y - 30*this.scale);\n\t};\n\n\n\t// draws labels for weapons recharge, reload indicators\n\tdrawLabels(ctx) {\n\t\tctx.font = \"18px Arial\";\n\t\tctx.fillStyle = \"#FAFAD2\";\n\n\t\tlet x_coord;\n\t\tif (this.beamWeaponName === \"Disruptor\") x_coord = this.ssd_x - 93;\n\t\telse x_coord = this.ssd_x - 85;\n\n\t\tconst y_coord = this.ssd_y;\n\n\t\tctx.fillText(this.beamWeaponName, x_coord, y_coord + 150 * this.scale);\n\t\tctx.fillText(\"Recharge\", this.ssd_x - 95, y_coord + 15 + 160 * this.scale);\n\n\t\tctx.fillText(\"Torpedo\", this.ssd_x + this.ssd_total_width + 20, \n\t\t\ty_coord + 150 * this.scale);\n\n\t\tctx.fillText(\"Reload\", this.ssd_x + this.ssd_total_width + 25, \n\t\t\ty_coord + 15 + 160 * this.scale);\n\t};\n\n\t\n\t// displays engine and beam damage, takes ellipse or rect from util as callbacks\n\tdrawSysDamageOnSSD(ctx, damageDim, callback) {\n\t\tlet y_coord = this.ssd_y + damageDim.y * this.scale;\n\t\n\t\tctx.beginPath();\n\t\tctx.fillStyle = \"yellow\";\n\n\t\tcallback(\n\t\t\tctx,\n\t\t\tthis.ssd_x + damageDim.left_x * this.scale, \n\t\t\ty_coord, \n\t\t\tdamageDim.width * this.scale, \n\t\t\tdamageDim.height * this.scale);\n\n\t\tcallback(\n\t\t\tctx,\n\t\t\tthis.ssd_x + damageDim.right_x * this.scale, \n\t\t\ty_coord, \n\t\t\tdamageDim.width * this.scale, \n\t\t\tdamageDim.height * this.scale);\n\t\t\t\n\t\tctx.fill();\n\t};\n\n\n\tdrawTorpIcon(ctx, torpImage, torpPos) {\n\t\tctx.drawImage(torpImage, \n\t\t\tthis.ssd_x + torpPos.x * this.scale, \n\t\t\tthis.ssd_y + torpPos.y * this.scale,  \n\t\t\t10*this.scale, 20*this.scale);\n\t};\n\n\n\t// draws system damage message\n\tdrawDamageLabel(ctx, label, y_addition, ratio) {\n\t\tctx.font = \"12px Arial\";\n\t\tctx.fillStyle = \"yellow\";\n\t\tctx.globalAlpha = 0.4;\n\t\t\n\t\tconst y_coord = this.ssd_y + 12 + y_addition * this.scale;\n\t\tlet x_text;\n\t\tlet x_clock;\n\n\t\tif (this.ssd_x < 150) {\n\t\t\tx_text = this.ssd_x + 90 + 74*this.scale;\n\t\t\tx_clock = x_text - 15;\n\t\t}\n\t\telse {\n\t\t\tx_text = this.ssd_x - 197;\n\t\t\tx_clock = this.ssd_x - 80;\n\t\t}\n\n\t\tctx.fillText(label, x_text, y_coord);\n\t\tctx.globalAlpha = 1;\n\n\t\tthis.drawClock(ctx, x_clock, y_coord -5, 8, ratio);\n\t};\n\n\n\t// draws the little clock that tells when system repairs are done\n\tdrawClock(ctx, x, y, radius, ratio) {\n\t\tconst start = Math.PI * -.5;\n\t\tconst end = Math.PI * (-.5 + ratio * 2);\n\n\t\tctx.fillStyle = \"yellow\";\n\t\tctx.strokeStyle = \"yellow\";\n\t\tctx.globalAlpha = 0.3;\n\n\t\t// circle on outside of clock\n\t\tctx.beginPath();\n\t\tctx.lineWidth = 2;\n\t\tctx.arc(x, y, radius + 2, 0, 2 * Math.PI);\n\t\tctx.stroke();\n\n\t\t// pie that fills in as time advances\n\t\tctx.beginPath();\n\t\tctx.moveTo(x, y);\n\t\tctx.arc(x, y, radius, start, end );\n\t\tctx.lineTo(x, y);\n\t\tctx.fill();\n\n\t\tctx.globalAlpha = 1;\n\t};\n\t\n\n\t// factory method to create shield objects\n\traiseShields() {\n\t\tconst x = this.ssd_x + this.ssd_total_width / 2;\n\t\tconst y = this.ssd_y + this.ssd_total_height / 2\n\n\t\t// forward shield\n\t\tthis.shields.push(new Shield({\n\t\t\tpos: [x, y + 10],\n\t\t\tstart: 1.3, end: 1.7,\n\t\t\tradius: 80 * this.scale,\n\t\t\tshieldStrength: this.shieldStrength\n\t\t}));\n\n\t\t// starboard shield\n\t\tthis.shields.push(new Shield({\n\t\t\tpos: [x - 30 * this.scale, y + 5],\n\t\t\tstart: 1.85, end: 2.15,\n\t\t\tradius: 100 * this.scale,\n\t\t\tshieldStrength: this.shieldStrength\n\t\t}));\n\n\t\t// rear shield\n\t\tthis.shields.push(new Shield({\n\t\t\tpos: [x, y - 1],\n\t\t\tstart: .3, end: .7,\n\t\t\tradius: 80 * this.scale,\n\t\t\tshieldStrength: this.shieldStrength\n\t\t}));\n\n\t\t// port shield\n\t\tthis.shields.push(new Shield({\n\t\t\tpos: [x + 30 * this.scale, y + 5],\n\t\t\tstart: .85, end: 1.15,\n\t\t\tradius: 100 * this.scale,\n\t\t\tshieldStrength: this.shieldStrength\n\t\t}));\n\t};\n}\n\nmodule.exports = SSD;\n\n//# sourceURL=webpack:///./src/ssd.js?");

/***/ }),

/***/ "./src/user_draw.js":
/*!**************************!*\
  !*** ./src/user_draw.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class UserDraw {\n\tconstructor(ctx) {\n\t\tthis.ctx = ctx;\n\t\tthis.boxX = 350;\n\t\tthis.boxY = 150;\n\t\tthis.boxWidth = 500;\n\t\tthis.boxHeight = 500;\n\n\t\tthis.strokeStyleFromUser = \"white\";\n\t\tthis.lineWidthFromUser = 20;\n\n\t\tthis.ctx.strokeStyle = \"white\";\n\t\tthis.ctx.lineWidth = 20;\n\t\tthis.started = false;\n\n\t\tthis.ctx.lineJoin = 'round';\n\t\tthis.ctx.lineCap = 'round';\n\n\t\tthis.allLines = [];\n\t\tthis.colors = [];\n\t\tthis.widths = [];\n\n\t\tthis.endLine();\n\t\tthis.mouseDown = false;\n\t}\n\n\tgetMouseDown() { return this.mouseDown; };\n\n\t\n\tsetMouseDown(val) {\n\t\tthis.mouseDown = val;\n\t\tif (val) this.addLine();\n\t\telse this.endLine();\n\t};\n\n\n\taddLine() {\n\t\tthis.allLines.push([]);\n\t\tthis.colors.push(this.strokeStyleFromUser);\n\t\tthis.widths.push(this.lineWidthFromUser);\n\t};\n\n\n\tendLine() {\n\t\tthis.prevX = null;\n\t\tthis.prevY = null;\n\t};\n\n\n\tdraw() {\n\t\tthis.drawBlackRectangleWithBorder(this.boxX, this.boxY, this.boxWidth, this.boxHeight);\n\n\t\tthis.drawAcceptButton();\n\n\t\tthis.ctx.fillStyle = \"lightblue\";\n\t\tthis.ctx.font = \"60px FINALOLD\";\n\t\tthis.ctx.fillText(\"Front of Ship\", 470, this.boxY - 25);\n\t\tthis.ctx.fillText(\"Rear of Ship\", 485, this.boxY + this.boxHeight + 63);\n\n\t\tthis.ctx.font = \"50px FINALOLD\";\n\n\t\tthis.drawColorChoices();\n\t\tthis.drawLineWidthChoices();\n\n\t\tif (!this.started) this.drawInstructions();\n\n\t\tthis.drawColorIndicator();\n\t\tthis.drawLineWidthIndicator();\n\n\t\t// draws the array holding the users drawing\n\t\tfor (let i = 0; i < this.allLines.length; i++) {\n\t\t\tthis.ctx.strokeStyle = this.colors[i];\n\t\t\tthis.ctx.lineWidth = this.widths[i];\n\t\t\tfor (let j = 0; j < this.allLines[i].length - 1; j++) {\n\t\t\t\tthis.ctx.beginPath();\n\t\t\t\tthis.ctx.moveTo(this.allLines[i][j][0], this.allLines[i][j][1]);\n\t\t\t\tthis.ctx.lineTo(this.allLines[i][j + 1][0], this.allLines[i][j + 1][1]);\n\t\t\t\tthis.ctx.stroke();\n\t\t\t}\n\t\t}\n\t};\n\n\n\tdrawBlackRectangleWithBorder(x, y, width, height, color = \"grey\", lineWidth = 1) {\n\t\tthis.ctx.beginPath();\n\n\t\tthis.ctx.lineWidth = lineWidth;\n\n\t\tthis.ctx.fillStyle = \"black\";\n\t\tthis.ctx.fillRect(x, y, width, height);\n\n\t\tthis.ctx.rect(x - 1, y - 1, width + 2, height + 2);\n\t\tthis.ctx.strokeStyle = color;\n\t\tthis.ctx.stroke();\n\t};\n\n\n\tdrawInstructions() {\n\t\tthis.ctx.fillStyle = \"white\";\n\t\tthis.ctx.font = \"60px FINALOLD\";\n\t\tthis.ctx.globalAlpha = 0.3;\n\t\tthis.ctx.fillText(\"Hold Down Mouse Button\", 361, this.boxY + 210);\n\t\tthis.ctx.fillText(\"to Draw in this Area\", 400, this.boxY + 310);\n\n\t\tthis.ctx.globalAlpha = 1;\n\t}\n\n\n\tdrawAcceptButton() {\n\t\tthis.ctx.beginPath();\n\n\t\tthis.drawBlackRectangleWithBorder(500, 802, 210, 50, \"lightblue\", 3);\n\t\tthis.ctx.stroke();\n\t\tthis.ctx.fillStyle = \"lightblue\";\n\t\tthis.ctx.font = \"40px FINALOLD\";\n\t\tthis.ctx.fillText(\"Click to Accept\", 510, 840);\n\t}\n\n\n\tdrawLineWidthChoices() {\n\n\t\tconst x = this.boxX + 550;\n\t\tconst y = this.boxY + 100;\n\n\t\tif (this.strokeStyleFromUser === \"black\") this.ctx.strokeStyle = \"white\";\n\t\telse this.ctx.strokeStyle = this.strokeStyleFromUser;\n\n\t\tthis.ctx.beginPath();\n\t\tthis.ctx.moveTo(x, y);\n\t\tthis.ctx.lineTo(x + 50, y);\n\t\tthis.ctx.lineWidth = 13;\n\t\tthis.ctx.stroke();\n\n\t\tthis.ctx.beginPath();\n\t\tthis.ctx.moveTo(x, y + 150);\n\t\tthis.ctx.lineTo(x + 50, y + 150);\n\t\tthis.ctx.lineWidth = 20;\n\t\tthis.ctx.stroke();\n\n\t\tthis.ctx.beginPath();\n\t\tthis.ctx.moveTo(x, y + 300);\n\t\tthis.ctx.lineTo(x + 50, y + 300);\n\t\tthis.ctx.lineWidth = 27;\n\t\tthis.ctx.stroke();\n\t};\n\n\n\tdrawLineWidthIndicator() {\n\n\t\tconst x = this.boxX + 550;\n\t\tconst y = this.boxY + 100;\n\n\t\tthis.ctx.lineWidth = 4;\n\t\tthis.ctx.beginPath();\n\t\tthis.ctx.strokeStyle = \"lightblue\";\n\n\t\tswitch (this.lineWidthFromUser) {\n\t\t\tcase 13:\n\t\t\t\tthis.ctx.strokeRect(x - 20, y - 20, 90, 40);\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tthis.ctx.strokeRect(x - 20, y - 20 + 150, 90, 40);\n\t\t\t\tbreak;\n\t\t\tcase 27:\n\t\t\t\tthis.ctx.strokeRect(x - 20, y - 20 + 300, 90, 40);\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\n\tdrawColorChoices() {\n\t\tconst x = this.boxX - 70;\n\t\tconst y = this.boxY + 33;\n\n\t\tthis.ctx.fillStyle = \"white\";\n\t\tthis.ctx.fillRect(x, y, 30, 30);\n\n\t\tthis.ctx.fillStyle = \"red\";\n\t\tthis.ctx.fillRect(x, y + 80, 30, 30);\n\n\t\tthis.ctx.fillStyle = \"blue\";\n\t\tthis.ctx.fillRect(x, y + 160, 30, 30);\n\n\t\tthis.ctx.fillStyle = \"yellow\";\n\t\tthis.ctx.fillRect(x, y + 240, 30, 30);\n\n\t\tthis.ctx.fillStyle = \"green\";\n\t\tthis.ctx.fillRect(x, y + 320, 30, 30);\n\n\t\tthis.drawBlackRectangleWithBorder(x, y + 400, 30, 30);\n\t\tthis.ctx.strokeStyle = \"white\";\n\t};\n\n\n\tdrawColorIndicator() {\n\n\t\tconst x = this.boxX - 70;\n\t\tconst y = this.boxY + 33;\n\n\t\tthis.ctx.lineWidth = 4;\n\t\tthis.ctx.strokeStyle = \"lightblue\";\n\t\tthis.ctx.beginPath();\n\n\t\tswitch (this.strokeStyleFromUser) {\n\t\t\tcase \"#ffffff\":\n\t\t\tcase \"white\":\n\t\t\t\tthis.ctx.strokeRect(x - 4, y - 4, 38, 38);\n\t\t\t\tbreak;\n\t\t\tcase \"#ff0000\":\n\t\t\tcase \"red\":\n\t\t\t\tthis.ctx.strokeRect(x - 4, y - 4 + 80, 38, 38);\n\t\t\t\tbreak;\n\t\t\tcase \"#0000ff\":\n\t\t\tcase \"blue\":\n\t\t\t\tthis.ctx.strokeRect(x - 4, y - 4 + 160, 38, 38);\n\t\t\t\tbreak;\n\t\t\tcase \"#ffff00\":\n\t\t\tcase \"yellow\":\n\t\t\t\tthis.ctx.strokeRect(x - 4, y - 4 + 240, 38, 38);\n\t\t\t\tbreak;\n\t\t\tcase \"#008000\":\n\t\t\tcase \"green\":\n\t\t\t\tthis.ctx.strokeRect(x - 4, y - 4 + 320, 38, 38);\n\t\t\t\tbreak;\n\t\t\tcase \"#000000\":\n\t\t\tcase \"black\":\n\t\t\t\tthis.ctx.strokeRect(x - 4, y - 4 + 400, 38, 38);\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\n\tchangeColor(y) {\n\t\tconst yOffset = this.boxY + 55;\n\n\t\tif (y >= yOffset && y <= yOffset + 30) this.strokeStyleFromUser = \"white\";\n\t\telse if (y >= yOffset + 80 && y <= yOffset + 110) this.strokeStyleFromUser = \"red\";\n\t\telse if (y >= yOffset + 160 && y <= yOffset + 190) this.strokeStyleFromUser = \"blue\";\n\t\telse if (y >= yOffset + 240 && y <= yOffset + 270) this.strokeStyleFromUser = \"yellow\";\n\t\telse if (y >= yOffset + 320 && y <= yOffset + 350) this.strokeStyleFromUser = \"green\";\n\t\telse if (y >= yOffset + 400 && y <= yOffset + 430) this.strokeStyleFromUser = \"black\";\n\t};\n\n\n\tchangeLineWidth(y) {\n\t\tif (y >= 170 && y < 330) this.lineWidthFromUser = 13;\n\t\telse if (y >= 330 && y < 490) this.lineWidthFromUser = 20;\n\t\telse if (y >= 490 && y < 670) this.lineWidthFromUser = 27;\n\t};\n\n\n\t// this was adapted from http://www.mattmorgante.com/technology/javascript-draw-html5-canvas\n\t// user can draw a ship in a box with cursor\n\tdrawFromUser(e) {\n\n\t\tif (e.offsetX >= this.boxX &&\n\t\t\te.offsetX <= this.boxX + this.boxWidth &&\n\t\t\te.offsetY >= this.boxY &&\n\t\t\te.offsetY <= this.boxY + this.boxHeight) {\n\n\t\t\t// reddraw area without instructions\n\t\t\tif (!this.started) this.started = true;\n\n\t\t\tthis.ctx.beginPath();\n\t\t\tthis.ctx.moveTo(this.prevX, this.prevY);\n\t\t\tthis.ctx.lineTo(e.offsetX, e.offsetY);\n\n\t\t\tif (this.prevX && this.prevY) this.ctx.stroke();\n\n\t\t\tthis.allLines[this.allLines.length - 1].push([e.offsetX, e.offsetY]);\n\n\t\t\tthis.prevX = e.offsetX;\n\t\t\tthis.prevY = e.offsetY;\n\t\t}\n\t\telse {\n\t\t\tthis.endLine();\n\t\t\tthis.addLine();\n\t\t}\n\t};\n\n\n\t// take user drawn picture\n\tacceptDrawing() {\n\t\tconst imgData = this.ctx.getImageData(this.boxX, this.boxY, this.boxWidth, this.boxHeight);\n\n\t\tconst virtualCanvas = document.createElement('canvas');\n\t\tvirtualCanvas.width = this.boxWidth;\n\t\tvirtualCanvas.height = this.boxHeight;\n\t\tconst virtualCtx = virtualCanvas.getContext('2d');\n\n\t\t// sets the black pixels to transparent\n\t\tfor (let index = 0; index < imgData.data.length; index += 4) {\n\t\t\tif (imgData.data[index] === 0 &&\n\t\t\t\timgData.data[index + 1] === 0 &&\n\t\t\t\timgData.data[index + 2] === 0\n\t\t\t\t)\n\t\t\t\timgData.data[index + 3] = 0;\n\t\t}\n\n\t\t// puts the imageData on a canvas and turns it into an Image\n\t\tvirtualCtx.putImageData(imgData, 0, 0);\n\t\tthis.img = new Image();\n\t\tthis.img.src = virtualCanvas.toDataURL();\n\n\t\tvirtualCtx.clearRect(0, 0, this.boxWidth, this.boxHeight);\n\n\t\t// this block puts the Image back onto a canvas and rotates it 90 degrees\n\t\tsetTimeout(() => {\n\t\t\tvirtualCtx.save();\n\t\t\tvirtualCtx.translate(this.boxWidth / 2, this.boxHeight / 2);\n\t\t\tvirtualCtx.rotate(Math.PI / 2);\n\t\t\tvirtualCtx.translate(-this.boxWidth / 2, -this.boxHeight / 2);\n\t\t\tvirtualCtx.drawImage(this.img, 0, 0, 500, 500, 0, 0, 500, 500);\n\n\t\t\tvirtualCtx.restore();\n\t\t\tthis.img.src = virtualCanvas.toDataURL();\n\t\t}, 1);\n\n\t\tthis.generateSSDImg(imgData);\n\t};\n\n\n\t// this generates the ssd portrait from user drawn picture\n\tgenerateSSDImg(imgData) {\n\n\t\t// turns the image grey for the ssd portrait\n\t\tfor (let index = 0; index < imgData.data.length; index += 4) {\n\t\t\tif (imgData.data[index] != 0 || imgData.data[index + 1] != 0 || imgData.data[index + 2] != 0) {\n\t\t\t\timgData.data[index] = 194;\n\t\t\t\timgData.data[index + 1] = 194;\n\t\t\t\timgData.data[index + 2] = 194;\n\t\t\t}\n\t\t}\n\t\tconst virtualCanvas = document.createElement('canvas');\n\t\tvirtualCanvas.width = this.boxWidth;\n\t\tvirtualCanvas.height = this.boxHeight;\n\t\tconst virtualCtx = virtualCanvas.getContext('2d');\n\n\t\tvirtualCtx.putImageData(imgData, 0, 0);\n\t\tthis.ssdImg = new Image();\n\n\t\tthis.ssdImg.src = virtualCanvas.toDataURL();\n\t};\n\n\tgetDrawing() { return this.img; }\n\n\tgetSSDportrait() { return this.ssdImg; }\n}\n\nmodule.exports = UserDraw;\n\n\n//# sourceURL=webpack:///./src/user_draw.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const Utils = {\n\n\tdistance(obj1, obj2) {\n\t\tlet distance_x = obj1[0] - obj2[0];\n\t\tlet distance_y = obj1[1] - obj2[1];\n\t\treturn Math.sqrt(distance_x * distance_x + distance_y * distance_y);\n\t},\n\t\n\t\n\tangleToOtherShip(ship, otherShip) {\n\n\t\tlet angle = this.findAngle(ship.center(),otherShip.center());\n\t\t\n\t\t// take the rotation of the hit ship into account\n\t\tangle -= ship.getRotation();\n\t\tif (angle < 0) angle += Math.PI * 2;\n\t\treturn angle;\n\t},\n\n\t\n\t// find the angle between the 2 objects\n\tfindAngle(point1, point2) {\n\t\tconst xDelta = point2[0] - point1[0];\n\t\tconst yDelta = point2[1] - point1[1];\n\n\t\tconst arcTangent = Math.atan(yDelta / xDelta);\n\t\tlet angle;\n\t\t\n\t\tif (xDelta < 0) angle = arcTangent + Math.PI;\n\t\telse if (xDelta > 0 && yDelta < 0) angle = arcTangent + Math.PI * 2;\n\t\telse angle = arcTangent;\n\n\t\treturn angle;\n\t},\n\n\n\tloadImg(file) {\n\t\tlet img = new Image();\n\t\timg.onload = () => { return true; }\n\t\timg.src = file;\n\t\treturn img;\n\t},\n\n\n\t// kind of a factory method to create a star\n\t// a version of this came from http://thenewcode.com/81/Make-A-Starfield-Background-with-HTML5-Canvas\n\tcreateStarData(xRange, yRange) {\n\t\tconst colorrange = [0, 60, 240];\n\t\treturn {\n\t\t\t\tpos: [Math.random() * xRange, Math.random() *yRange],\n\t\t\t\tradius: Math.random() * 2.0,\n\t\t\t\thue: colorrange[Utils.getRandom(0, colorrange.length - 1)],\n\t\t\t\tsat: this.getRandom(50, 100),\n\t\t\t};\t\n\t},\n\t// helper method\n\tgetRandom(min, max) {\n\t\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n\t},\n\n\n\t// draw a red circle with a vert and a horiz line like crosshairs\n\tdrawTarget(ctx, x, y, size, lw, color = \"red\") {\n\n\t\tctx.beginPath();\n\t\tctx.strokeStyle = color;\n\t\tctx.lineWidth = lw;\n\t\tctx.arc(x, y, size, 0, 2 * Math.PI);\n\n\t\tctx.moveTo(x, y - size);\n\t\tctx.lineTo(x, y + size);\n\t\tctx.moveTo(x - size, y);\n\t\tctx.lineTo(x + size, y);\n\t\t\n\t\tctx.stroke();\n\t}, \n\n\n\t// callback for ship beam effect\n\tdrawLine(ctx, from, to){\n\t\tctx.moveTo(to.x, to.y);\n\t\tctx.lineTo(from.x, from.y);\n\t},\n\n\n\t// a version of this came from https://codepen.io/alexkulagin/pen/wGwpdx\n\t// callback for ship beam effect\n\tdrawWavyLine(ctx, from, to) {\n\t\tlet cx = 0;\n\t\tlet cy = 0;\n\t\tlet waveOffsetLength;\n\n\t\tconst ang = Math.atan2(to.y - from.y, to.x - from.x);\n\t\tconst distance = Math.sqrt((from.x - to.x) * (from.x - to.x) + \n\t\t\t(from.y - to.y) * (from.y - to.y));\n\t\t\n\t\tconst frequency = 1/ 8;\n\t\tconst amplitude = 3;\n\n\t\tconst f = Math.PI * frequency *distance;\n\n\t\tlet step = 1;\t// lower step makes curve smoother\n\t\tfor (let i = 0; i <= distance; i += step) {\n\t\t\twaveOffsetLength = Math.sin((i / distance) * f) * amplitude;\n\t\t\tcx = from.x + Math.cos(ang) * i + Math.cos(ang - Math.PI / 2) * waveOffsetLength;\n\t\t\tcy = from.y + Math.sin(ang) * i + Math.sin(ang - Math.PI / 2) * waveOffsetLength;\n\t\t\ti > 0 ? ctx.lineTo(cx, cy) : ctx.moveTo(cx, cy);\n\t\t}\n\t},\n\n\n\t// callback for ship beam effect\n\tdrawCircleBeam(ctx, from, to) {\n\t\tconst separation = 15;\n\t\tlet ratio;\n\t\tconst xDelta = to.x - from.x;\n\t\tconst yDelta = to.y - from.y;\n\t\tconst distance = Math.sqrt(xDelta*xDelta + yDelta*yDelta)\n\n\t\tconst angle = Utils.findAngle([from.x, from.y], [to.x, to.y] );\n\n\t\tctx.lineWidth = 1;\n\t\t\n\t\tfor(let i = 0; i <= distance; i += separation) {\n\t\t\tratio = i / distance;\n\t\t\tctx.beginPath();\n\t\t\tctx.ellipse(from.x + xDelta*ratio, from.y + yDelta*ratio, \n\t\t\t\tratio*2, ratio*5, angle, 0, 2 * Math.PI);\n\t\t\tctx.stroke();\n\t\t}\n\t},\n\t\n\n\tdrawFilledCircle(ctx, x, y, radius, fillStyle) {\n\t\tctx.beginPath();\n\t\tctx.arc(x, y, radius, 0, 360);\n\t\tctx.fillStyle = fillStyle;\n\t\tctx.fill();\n\t},\n\n\n\t// wrapper so that I can use ctx.ellipse as a callback\n\tdrawEllipse(ctx, x, y, width, height) {\n\t\tctx.ellipse(x, y, width, height, 0, 0, Math.PI * 2);\n\t},\n\n\n\t// wrapper so that I can use ctx.rect as a callback\n\tdrawRect(ctx, x, y, width, height) {\n\t\tctx.rect(x, y, width, height);\n\t},\n\n\n\tgetCanvasDim() { return {x:1200, y:900}; }\n}\n\nmodule.exports = Utils;\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ })

/******/ });